<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE2 CIRCUIT - HARDCORE STRANGER</title>
    <style>
        @font-face {
            font-family: 'RE_Font';
            src: url('resident_evil_4_remake_font_by_snakeyboy_df7kacs.ttf');
        }

        :root { 
            --pwr-color: #f1c40f; 
            --bg-color: #050505;
            --re-red: #8b0000;
            --locked-bg: #2b0000;
        }

        body { 
            background-color: var(--bg-color); 
            color: #ccc; 
            font-family: 'RE_Font', 'Courier New', sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            margin: 0; height: 100vh; justify-content: center;
            background-image: radial-gradient(circle, #1a1a1a 0%, #000 100%);
        }

        h2 { color: var(--re-red); text-transform: uppercase; letter-spacing: 5px; margin-bottom: 10px; font-size: 2em; }

        #info-panel { 
            margin-bottom: 15px; font-size: 1.2em; display: flex; gap: 40px; 
            background: rgba(20, 20, 20, 0.9); padding: 10px 30px; border: 1px solid #444;
        }

        .timer { color: #f00; }
        .timer.warning { animation: flicker 0.2s infinite; }

        #game-container { 
            position: relative; padding: 50px; background: #111; border: 4px solid #333;
            box-shadow: 0 0 100px #000;
        }

        #game-board { display: grid; gap: 4px; background: #000; padding: 4px; }

        .port-label { position: absolute; font-size: 14px; color: #444; text-transform: uppercase; }
        #start-label { left: 15px; top: 75px; color: var(--pwr-color); }
        #end-label { right: 15px; bottom: 75px; }

        .tile { 
            width: 75px; height: 75px; background: #151515; 
            cursor: pointer; position: relative; transition: transform 0.2s;
        }
        .tile:hover:not(.locked) { background: #222; }

        .tile.locked { 
            cursor: not-allowed; background: var(--locked-bg);
            border: 1px solid #500;
        }
        .tile.locked::before {
            content: 'FIXED'; position: absolute; font-size: 9px; color: #f00;
            top: 2px; left: 2px; z-index: 10;
        }

        .wire { position: absolute; background: #333; z-index: 1; transition: background 0.3s; }
        .tile::after {
            content: ''; position: absolute; width: 14px; height: 14px;
            background: #333; left: 30.5px; top: 30.5px; border-radius: 2px; z-index: 2;
        }

        .w-up { width: 8px; height: 38px; left: 33.5px; top: 0; }
        .w-right { width: 38px; height: 8px; left: 37.5px; top: 33.5px; }
        .w-down { width: 8px; height: 38px; left: 33.5px; top: 37.5px; }
        .w-left { width: 38px; height: 8px; left: 0; top: 33.5px; }

        .powered .wire, .powered::after { 
            background: var(--pwr-color) !important; 
            box-shadow: 0 0 15px var(--pwr-color); 
        }

        .overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.98); display: none; 
            flex-direction: column; justify-content: center; align-items: center; z-index: 100; 
            text-align: center;
        }
        
        #status-text { font-size: 4em; margin-bottom: 20px; font-family: 'RE_Font', serif; }
        .dead-text { color: #f00; text-shadow: 0 0 20px #f00; }
        .alive-text { color: #0f0; text-shadow: 0 0 20px #0f0; }
        .stranger-text { color: #f1c40f; font-size: 2.5em !important; line-height: 1.5; }

        #action-btn { 
            background: transparent; color: #fff; border: 1px solid #666; 
            padding: 15px 50px; cursor: pointer; font-size: 1.5em; 
            font-family: 'RE_Font', sans-serif;
        }
        #action-btn:hover { background: #800; border-color: #f00; }
        .hidden { display: none; }

        @keyframes flicker { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <h2>CIRCUIT CONTROL HARDCORE</h2>
    
    <div id="info-panel">
        <div>LVL: <span id="lvl-display">1</span></div>
        <div class="timer">SEC: <span id="time-display">60</span></div>
    </div>

    <div id="game-container">
        <div id="start-label" class="port-label">IN</div>
        <div id="game-board"></div>
        <div id="end-label" class="port-label">OUT</div>
    </div>

    <div id="overlay" class="overlay">
        <h1 id="status-text">YOU ARE DEAD</h1>
        <button id="action-btn" onclick="handleBtnClick()">RETRY</button>
    </div>

<script>
    const levels = [{size:3, lock:0}, {size:4, lock:3}, {size:5, lock:6}];
    let currentLvl = 0;
    let timeLeft = 60;
    let timerId = null;
    let tiles = [];
    let isLocked = false;

    function startGame() {
        isLocked = false;
        document.getElementById('overlay').style.display = 'none';
        const config = levels[currentLvl];
        timeLeft = 60;
        document.getElementById('lvl-display').innerText = currentLvl + 1;
        generateEvilBoard(config.size, config.lock);
        startTimer();
    }

    function generateEvilBoard(size, lockCount) {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        boardEl.style.gridTemplateColumns = `repeat(${size}, 75px)`;
        tiles = [];

        // 1. 生成唯一正確路徑
        let solution = new Set();
        let path = [];
        let r = 0, c = 0;
        path.push({r, c});
        while(r < size-1 || c < size-1) {
            if(r < size-1 && (Math.random() > 0.6 || c === size-1)) r++;
            else c++;
            path.push({r, c});
            solution.add(`${r},${c}`);
        }

        // 2. 建立資料結構
        const grid = Array.from({length: size}, () => Array.from({length: size}, () => ({exits:[]})));
        grid[0][0].exits.push(3); // 起點輸入
        grid[size-1][size-1].exits.push(1); // 終點輸出

        for(let i=0; i<path.length-1; i++) {
            const curr = path[i], next = path[i+1];
            if(next.r > curr.r) { grid[curr.r][curr.c].exits.push(2); grid[next.r][next.c].exits.push(0); }
            else { grid[curr.r][curr.c].exits.push(1); grid[next.r][next.c].exits.push(3); }
        }

        // 3. 填充所有方塊
        for(let r=0; r<size; r++) {
            for(let c=0; c<size; c++) {
                const idx = r * size + c;
                let data = grid[r][c];
                
                // 非路徑方塊：給予極具誤導性的 L 或 I 型
                if(data.exits.length === 0) {
                    const types = [[0,2], [1,3], [0,1], [1,2], [2,3], [3,0]];
                    data.exits = types[Math.floor(Math.random()*types.length)];
                }

                const tileWrap = document.createElement('div');
                tileWrap.className = 'tile';
                
                // 增加鎖定難度：路徑上的方塊也有機率被鎖定
                let isFixed = (lockCount > 0 && idx !== 0 && Math.random() > 0.6);
                if(isFixed) { tileWrap.classList.add('locked'); lockCount--; }

                let rot = isFixed ? 0 : Math.floor(Math.random() * 4);
                const tileObj = {
                    element: tileWrap,
                    baseExits: data.exits,
                    currentRotation: rot,
                    isLocked: isFixed,
                    getActualExits: function() { return this.baseExits.map(ex => (ex + this.currentRotation) % 4); }
                };

                tileObj.baseExits.forEach(d => {
                    const w = document.createElement('div');
                    w.className = 'wire ' + ['w-up', 'w-right', 'w-down', 'w-left'][d];
                    tileWrap.appendChild(w);
                });

                tileWrap.style.transform = `rotate(${rot * 90}deg)`;
                tileWrap.onclick = () => {
                    if(isLocked || tileObj.isLocked) return;
                    tileObj.currentRotation = (tileObj.currentRotation + 1) % 4;
                    tileWrap.style.transform = `rotate(${tileObj.currentRotation * 90}deg)`;
                    checkCircuit();
                };
                boardEl.appendChild(tileWrap);
                tiles.push(tileObj);
            }
        }
        checkCircuit();
    }

    function checkCircuit() {
        const size = levels[currentLvl].size;
        tiles.forEach(t => t.element.classList.remove('powered'));
        const powered = new Set(), queue = [0];
        if(!tiles[0].getActualExits().includes(3)) return;

        while(queue.length > 0) {
            const idx = queue.shift();
            if(powered.has(idx)) continue;
            powered.add(idx);
            tiles[idx].element.classList.add('powered');
            const r = Math.floor(idx/size), c = idx%size;
            const exits = tiles[idx].getActualExits();
            const nbs = [{d:0,nr:r-1,nc:c,o:2},{d:1,nr:r,nc:c+1,o:3},{d:2,nr:r+1,nc:c,o:0},{d:3,nr:r,nc:c-1,o:1}];
            nbs.forEach(n => {
                if(exits.includes(n.d) && n.nr>=0 && n.nr<size && n.nc>=0 && n.nc<size) {
                    const nIdx = n.nr*size + n.nc;
                    if(tiles[nIdx].getActualExits().includes(n.o)) queue.push(nIdx);
                }
            });
        }

        if(powered.has(tiles.length-1) && tiles[tiles.length-1].getActualExits().includes(1)) {
            isLocked = true; clearInterval(timerId);
            setTimeout(() => {
                if(currentLvl < levels.length - 1) showOverlay("ALIVE", "NEXT LEVEL");
                else showOverlay("Congratulations, stranger! Please claim your reward.", "");
            }, 500);
        }
    }

    function startTimer() {
        clearInterval(timerId);
        timerId = setInterval(() => {
            if(isLocked) return;
            timeLeft--;
            document.getElementById('time-display').innerText = timeLeft;
            if(timeLeft <= 10) document.querySelector('.timer').classList.add('warning');
            if(timeLeft <= 0) endGame();
        }, 1000);
    }

    function endGame() { isLocked = true; clearInterval(timerId); showOverlay("YOU ARE DEAD", "RETRY"); }

    function showOverlay(msg, btnTxt) {
        const overlay = document.getElementById('overlay');
        const txt = document.getElementById('status-text');
        const btn = document.getElementById('action-btn');
        txt.innerText = msg;
        btn.innerText = btnTxt;
        if(msg.includes("Congratulations")) { txt.className = "stranger-text"; btn.classList.add("hidden"); }
        else { txt.className = (msg === "ALIVE") ? "alive-text" : "dead-text"; btn.classList.remove("hidden"); }
        overlay.style.display = 'flex';
    }

    function handleBtnClick() { currentLvl = (document.getElementById('action-btn').innerText === "NEXT LEVEL") ? currentLvl+1 : 0; startGame(); }

    startGame();
</script>
</body>
</html>
