<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修 - 關卡配置版</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: sans-serif; }
        canvas { background: #000; border: 2px solid #333; margin-top: 10px; }
    </style>
</head>
<body>
    <h3 style="color:#00ffcc">關卡配置：每圈 4 紅框 + 電源對齊不遮擋</h3>
    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 定義標準座標常量
        const CX = 450; 
        const CY = 425;
        const BOXES = [
            { x: 100, y: 100, w: 650, h: 650 }, // 外框 (BOX1)
            { x: 200, y: 200, w: 450, h: 450 }, // 中框 (BOX2)
            { x: 300, y: 300, w: 250, h: 250 }  // 內框 (BOX3)
        ];

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 左上角電池
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(50, 20, 150, 70);
            ctx.strokeStyle = "#00ffcc";
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 20, 150, 70);

            // 2. 電線佈局 (灰色虛線)
            ctx.strokeStyle = "#444";
            ctx.setLineDash([5, 8]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // 引線
            ctx.moveTo(200, 55); ctx.lineTo(CX, 55); ctx.lineTo(CX, 100);

            // 三層框與十字軸
            BOXES.forEach(b => ctx.strokeRect(b.x, b.y, b.w, b.h));
            ctx.moveTo(CX, 55); ctx.lineTo(CX, 750); // 垂直
            ctx.moveTo(100, CY); ctx.lineTo(750, CY); // 水平
            ctx.stroke();

            // 3. 放置 6 個電源點 (放置在角落或末端，避免與紅框重疊)
            ctx.setLineDash([]);
            const targets = [
                {x: CX, y: CY},                       // 中心點
                {x: BOXES[0].x + BOXES[0].w, y: 100}, // 右上角
                {x: BOXES[0].x, y: 750},              // 左下角
                {x: BOXES[1].x + BOXES[1].w, y: 200}, // 中圈右上
                {x: BOXES[2].x, y: 300},              // 內圈左上
                {x: 750, y: 550}                      // 右側支線
            ];
            targets.forEach(t => {
                ctx.strokeStyle = "#00ffcc";
                ctx.beginPath(); ctx.arc(t.x, t.y, 22, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = "#004433";
                ctx.beginPath(); ctx.arc(t.x, t.y, 5, 0, Math.PI*2); ctx.fill();
            });

            // 4. 放置 16 個紅框節點 (每圈四個邊的中點各一個)
            const nodes = [];
            // 每圈 4 個 (中點對齊)
            BOXES.forEach(b => {
                nodes.push({x: CX, y: b.y});           // 上邊中點
                nodes.push({x: CX, y: b.y + b.h});     // 下邊中點
                nodes.push({x: b.x, y: CY});           // 左邊中點
                nodes.push({x: b.x + b.w, y: CY});     // 右邊中點
            });
            // 補足至 16 個 (在十字軸與方框間的轉折處)
            nodes.push({x: CX, y: 150}, {x: CX, y: 650}, {x: 250, y: CY}, {x: 650, y: CY});

            nodes.forEach(n => {
                ctx.strokeStyle = "red";
                ctx.lineWidth = 1.5;
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50);
            });
        }

        drawMap();
    </script>
</body>
</html>

