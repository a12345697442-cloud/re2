<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路解謎遊戲</title>
    <style>
        body { background: #1a1a1a; color: white; text-align: center; font-family: sans-serif; }
        canvas { background: #fdfdfd; cursor: pointer; border: 5px solid #333; margin-top: 20px; }
        .hint { color: #888; margin-top: 10px; }
    </style>
</head>
<body>

    <h2>電路解謎遊戲</h2>
    <div class="hint">點擊紅框旋轉符號，連接電池與綠燈</div>
    <canvas id="gameCanvas" width="800" height="800"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const GRID_SIZE = 80;
        const OFFSET = 120;

        // 符號類型
        const T_SHAPE = 'T';
        const L_SHAPE = 'L';
        const D_CURVE = 'D'; // 黃色雙彎道

        // 模擬地圖 (x, y 為網格座標)
        // 這裡我先幫你建立一個十字形的基礎，你可以自行增加
        let nodes = [
            { x: 4, y: 1, type: T_SHAPE, rot: 2, power: false }, // 靠近頂部電池
            { x: 4, y: 2, type: L_SHAPE, rot: 1, power: false },
            { x: 4, y: 3, type: D_CURVE, rot: 0, power: false, isYellow: true }, // 黃色特殊件
            { x: 3, y: 3, type: T_SHAPE, rot: 0, power: false },
            { x: 5, y: 3, type: L_SHAPE, rot: 3, power: false },
            { x: 4, y: 4, type: 'LAMP', power: false } // 中心綠燈
        ];

        // 定義哪些點之間有「線路」
        let wires = [
            { from: {x:4, y:0}, to: {x:4, y:1} }, // 電池到第一個點
            { from: {x:4, y:1}, to: {x:4, y:2} },
            { from: {x:4, y:2}, to: {x:4, y:3} },
            { from: {x:4, y:3}, to: {x:4, y:4} },
            { from: {x:3, y:3}, to: {x:4, y:3} },
            { from: {x:4, y:3}, to: {x:5, y:3} }
        ];

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 畫電池 (頂部黑框)
            ctx.fillStyle = '#222';
            ctx.fillRect(4 * GRID_SIZE + OFFSET - 30, 10, 60, 40);

            // 2. 畫背景電路線 (虛線)
            ctx.strokeStyle = '#333';
            ctx.setLineDash([5, 8]);
            ctx.lineWidth = 2;
            wires.forEach(w => {
                ctx.beginPath();
                ctx.moveTo(w.from.x * GRID_SIZE + OFFSET, w.from.y * GRID_SIZE + OFFSET);
                ctx.lineTo(w.to.x * GRID_SIZE + OFFSET, w.to.y * GRID_SIZE + OFFSET);
                ctx.stroke();
            });
            ctx.setLineDash([]); // 恢復實線

            // 3. 畫符號節點
            nodes.forEach(n => {
                const px = n.x * GRID_SIZE + OFFSET;
                const py = n.y * GRID_SIZE + OFFSET;

                // 畫紅色外框
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                ctx.strokeRect(px - 28, py - 28, 56, 56);

                // 畫內部符號
                ctx.save();
                ctx.translate(px, py);
                if(n.type !== 'LAMP') ctx.rotate(n.rot * Math.PI / 2);
                
                drawSymbol(n);
                ctx.restore();
            });
        }

        function drawSymbol(n) {
            ctx.lineWidth = 4;
            ctx.strokeStyle = n.isYellow ? '#ffcc00' : '#005596';
            
            if (n.type === T_SHAPE) {
                ctx.beginPath();
                ctx.moveTo(-28, 0); ctx.lineTo(28, 0);
                ctx.moveTo(0, 0); ctx.lineTo(0, 28);
                ctx.stroke();
            } else if (n.type === L_SHAPE) {
                ctx.beginPath();
                ctx.moveTo(0, -28); ctx.lineTo(0, 0); ctx.lineTo(28, 0);
                ctx.stroke();
            } else if (n.type === D_CURVE) {
                // 黃色雙彎道邏輯：兩條互不相干的弧線
                ctx.beginPath();
                ctx.arc(-28, -28, 28, 0, Math.PI / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(28, 28, 28, Math.PI, Math.PI * 1.5);
                ctx.stroke();
            } else if (n.type === 'LAMP') {
                ctx.fillStyle = n.power ? '#00ff00' : '#ccc';
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        // 點擊事件
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            nodes.forEach(n => {
                const px = n.x * GRID_SIZE + OFFSET;
                const py = n.y * GRID_SIZE + OFFSET;
                if (mx > px - 28 && mx < px + 28 && my > py - 28 && my < py + 28) {
                    if(n.type !== 'LAMP') {
                        n.rot = (n.rot + 1) % 4;
                        draw();
                    }
                }
            });
        });

        draw();
    </script>
</body>
</html>
