我明白你的意思了！之前的邏輯雖然加上了兩個出口，但因為路徑生成太過「正直」，導致兩條線路只是平行並進，完全沒有互相干擾，這確實讓雙出口失去了意義。

要讓難度真正爆表，關鍵在於：兩條路徑必須「交叉」或「繞路」，且第 2、3 關的方塊應該要以 L 型（直角） 為主，強迫你必須在轉角處精確計算。

我重新編寫了 「混亂演算法」：

交叉路徑 (Crossed Paths)：第一條線路會從左上繞到右下，第二條線路會從左下繞到右上。它們會在中心點強烈干擾。

單一接口 (Minimal Connectors)：大幅減少三向和四向方塊，增加大量 L 型方塊。這意味著一旦有一格轉錯，整條電路會完全斷掉。

雜訊填充：非正確路徑的格子會填滿極具誤導性的線路，讓畫面看起來像迷宮。

究極 Hardcore 版 index.html
HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE2 CIRCUIT - INSANE MODE</title>
    <style>
        @font-face {
            font-family: 'RE_Font';
            src: url('resident_evil_4_remake_font_by_snakeyboy_df7kacs.ttf');
        }

        :root { 
            --pwr-color: #f1c40f; 
            --bg-color: #050505;
            --re-red: #8b0000;
            --locked-bg: #2b0000;
        }

        body { 
            background-color: var(--bg-color); color: #ccc; 
            font-family: 'RE_Font', 'Courier New', sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            margin: 0; height: 100vh; justify-content: center;
            background-image: radial-gradient(circle, #1a1a1a 0%, #000 100%);
        }

        h2 { color: var(--re-red); text-transform: uppercase; letter-spacing: 5px; margin-bottom: 10px; font-size: 2em; }

        #info-panel { 
            margin-bottom: 15px; font-size: 1.2em; display: flex; gap: 40px; 
            background: rgba(20, 20, 20, 0.9); padding: 10px 30px; border: 1px solid #444;
        }

        .timer { color: #f00; font-weight: bold; }
        #game-container { position: relative; padding: 60px; background: #111; border: 4px solid #333; box-shadow: 0 0 100px #000; }
        #game-board { display: grid; gap: 5px; background: #000; padding: 5px; }

        .port { position: absolute; font-size: 11px; font-weight: bold; text-transform: uppercase; z-index: 5; }
        .in-p { color: var(--pwr-color); left: 10px; }
        .out-p { right: 10px; color: #444; }
        .out-p.active { color: var(--pwr-color); text-shadow: 0 0 10px var(--pwr-color); }
        
        /* 入口與出口的位置錯開，強迫交叉 */
        .p-1 { top: 85px; }
        .p-2 { bottom: 85px; }

        .tile { width: 75px; height: 75px; background: #151515; cursor: pointer; position: relative; transition: transform 0.2s; box-sizing: border-box; }
        .tile.locked { cursor: not-allowed; background: var(--locked-bg); border: 1px solid #600; }
        .tile.locked::before { content: 'FIXED'; position: absolute; font-size: 8px; color: #f00; top: 2px; left: 2px; z-index: 10; opacity: 0.8; }

        .wire { position: absolute; background: #333; z-index: 1; transition: background 0.3s; }
        .tile::after { content: ''; position: absolute; width: 14px; height: 14px; background: #333; left: 30.5px; top: 30.5px; border-radius: 2px; z-index: 2; }

        .w-up { width: 8px; height: 38px; left: 33.5px; top: 0; }
        .w-right { width: 38px; height: 8px; left: 37.5px; top: 33.5px; }
        .w-down { width: 8px; height: 38px; left: 33.5px; top: 37.5px; }
        .w-left { width: 38px; height: 8px; left: 0; top: 33.5px; }

        .powered .wire, .powered::after { background: var(--pwr-color) !important; box-shadow: 0 0 15px var(--pwr-color); }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.98); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        #status-text { font-size: 4em; margin-bottom: 20px; font-family: 'RE_Font', serif; letter-spacing: 2px; }
        .stranger-text { 
            color: #f1c40f; font-size: 2.5em !important; 
            line-height: 2; letter-spacing: 10px !important; 
            text-shadow: 0 0 25px rgba(241, 196, 15, 0.7); 
            white-space: pre-line;
        }
        .dead-text { color: #f00; text-shadow: 0 0 20px #f00; }
        .alive-text { color: #0f0; text-shadow: 0 0 20px #0f0; }

        button { background: transparent; color: #fff; border: 1px solid #666; padding: 15px 50px; cursor: pointer; font-size: 1.5em; font-family: 'RE_Font', sans-serif; }
        button:hover { background: #800; border-color: #f00; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <h2>CIRCUIT CONTROL: INSANE</h2>
    
    <div id="info-panel">
        <div>LEVEL: <span id="lvl-display">1</span></div>
        <div class="timer">TIMER: <span id="time-display">60</span></div>
    </div>

    <div id="game-container">
        <div class="port in-p p-1">INPUT A</div>
        <div id="in2-label" class="port in-p p-2 hidden">INPUT B</div>
        
        <div id="game-board"></div>
        
        <div id="out1-label" class="port out-p p-1">OUTPUT A</div>
        <div id="out2-label" class="port out-p p-2 hidden">OUTPUT B</div>
    </div>

    <div id="overlay" class="overlay">
        <h1 id="status-text"></h1>
        <button id="action-btn" onclick="handleBtnClick()">RETRY</button>
    </div>

<script>
    const levels = [
        {size: 3, dual: false, locks: 0},
        {size: 4, dual: true, locks: 3},
        {size: 5, dual: true, locks: 6}
    ];
    let currentLvl = 0, timeLeft = 60, timerId = null, tiles = [], isLocked = false;

    function startGame() {
        isLocked = false;
        document.getElementById('overlay').style.display = 'none';
        const cfg = levels[currentLvl];
        document.getElementById('lvl-display').innerText = currentLvl + 1;
        document.getElementById('in2-label').classList.toggle('hidden', !cfg.dual);
        document.getElementById('out2-label').classList.toggle('hidden', !cfg.dual);
        generateInsaneLevel(cfg);
        startTimer();
    }

    function generateInsaneLevel(cfg) {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        boardEl.style.gridTemplateColumns = `repeat(${cfg.size}, 75px)`;
        tiles = [];

        const gridData = Array.from({length: cfg.size}, () => Array.from({length: cfg.size}, () => ({exits:[]})));
        
        // 核心改變：路徑必須大迴轉或交叉
        // 路徑 A: 左上 (0,0) -> 右上 (0, size-1) 但強迫向下繞路
        createWindingPath(gridData, 0, 0, 0, cfg.size-1, 3, 1, cfg.size, true);
        
        if(cfg.dual) {
            // 路徑 B: 左下 (size-1, 0) -> 右下 (size-1, size-1) 強迫向上繞路
            createWindingPath(gridData, cfg.size-1, 0, cfg.size-1, cfg.size-1, 3, 1, cfg.size, false);
        }

        for(let r=0; r<cfg.size; r++){
            for(let c=0; c<cfg.size; c++){
                let data = gridData[r][c];
                // 填充更具迷惑性的 L 型方塊
                if(data.exits.length === 0) {
                    const lTypes = [[0,1],[1,2],[2,3],[3,0]];
                    data.exits = lTypes[Math.floor(Math.random()*4)];
                } else if (data.exits.length === 1) {
                    // 確保至少有兩個出口
                    let other = [0,1,2,3].filter(d => d !== data.exits[0]);
                    data.exits.push(other[Math.floor(Math.random()*3)]);
                }

                const tileWrap = document.createElement('div');
                tileWrap.className = 'tile';
                
                // 增加鎖定方塊的戰略性
                let isFixed = (cfg.locks > 0 && Math.random() > 0.6 && (r+c > 0));
                if(isFixed) { tileWrap.classList.add('locked'); cfg.locks--; }

                let rot = isFixed ? 0 : Math.floor(Math.random()*4);
                const tileObj = {
                    element: tileWrap,
                    baseExits: [...new Set(data.exits)],
                    currentRotation: rot, 
                    isLocked: isFixed,
                    getActualExits: function() { return this.baseExits.map(ex => (ex + this.currentRotation) % 4); }
                };

                tileObj.baseExits.forEach(d => {
                    const w = document.createElement('div');
                    w.className = 'wire ' + ['w-up', 'w-right', 'w-down', 'w-left'][d];
                    tileWrap.appendChild(w);
                });

                tileWrap.style.transform = `rotate(${rot * 90}deg)`;
                tileWrap.onclick = () => { 
                    if(!isLocked && !tileObj.isLocked) { 
                        tileObj.currentRotation = (tileObj.currentRotation + 1) % 4; 
                        tileWrap.style.transform = `rotate(${tileObj.currentRotation * 90}deg)`; 
                        checkCircuit(); 
                    } 
                };
                boardEl.appendChild(tileWrap);
                tiles.push(tileObj);
            }
        }
        checkCircuit();
    }

    // 生成繞路路徑：強迫路徑在中間區域穿梭
    function createWindingPath(grid, sr, sc, er, ec, startDir, endDir, size, wrapDown) {
        let r = sr, c = sc;
        grid[r][c].exits.push(startDir);
        
        // 簡單的人工繞路：先往中間走
        let mid = Math.floor(size / 2);
        let targetR = wrapDown ? mid : mid - 1;

        // 走到中間列
        while(r !== targetR) {
            let lastR = r;
            r = (r < targetR) ? r+1 : r-1;
            grid[lastR][c].exits.push(r > lastR ? 2 : 0);
            grid[r][c].exits.push(r > lastR ? 0 : 2);
        }

        // 橫向移動到最後一格前
        while(c < size - 1) {
            let lastC = c;
            c++;
            grid[r][lastC].exits.push(1);
            grid[r][c].exits.push(3);
        }

        // 回到終點列
        while(r !== er) {
            let lastR = r;
            r = (r < er) ? r+1 : r-1;
            grid[lastR][c].exits.push(r > lastR ? 2 : 0);
            grid[r][c].exits.push(r > lastR ? 0 : 2);
        }
        grid[er][ec].exits.push(endDir);
    }

    function checkCircuit() {
        const cfg = levels[currentLvl];
        const size = cfg.size;
        
        const p1 = trace(0, 3, size);
        const p2 = cfg.dual ? trace((size-1)*size, 3, size) : new Set();

        tiles.forEach((t, i) => {
            if(p1.has(i) || (cfg.dual && p2.has(i))) t.element.classList.add('powered');
            else t.element.classList.remove('powered');
        });

        const win1 = p1.has(size-1) && tiles[size-1].getActualExits().includes(1);
        const win2 = !cfg.dual || (p2.has(size*size-1) && tiles[size*size-1].getActualExits().includes(1));

        document.getElementById('out1-label').classList.toggle('active', win1);
        if(cfg.dual) document.getElementById('out2-label').classList.toggle('active', win2);

        if(win1 && win2) {
            isLocked = true; clearInterval(timerId);
            setTimeout(() => {
                if(currentLvl < levels.length - 1) showOverlay("ALIVE", "NEXT LEVEL");
                else showOverlay("Congratulations, stranger!\nPlease claim your reward.", "");
            }, 600);
        }
    }

    function trace(startIdx, startEntryDir, size) {
        const powered = new Set(), queue = [];
        if(tiles[startIdx].getActualExits().includes(startEntryDir)) queue.push(startIdx);
        while(queue.length > 0) {
            const idx = queue.shift();
            if(powered.has(idx)) continue;
            powered.add(idx);
            const r = Math.floor(idx/size), c = idx%size, exits = tiles[idx].getActualExits();
            const neighbors = [{d:0,nr:r-1,nc:c,o:2},{d:1,nr:r,nc:c+1,o:3},{d:2,nr:r+1,nc:c,o:0},{d:3,nr:r,nc:c-1,o:1}];
            neighbors.forEach(n => {
                if(exits.includes(n.d) && n.nr>=0 && n.nr<size && n.nc>=0 && n.nc<size) {
                    const nIdx = n.nr*size + n.nc;
                    if(tiles[nIdx].getActualExits().includes(n.opp || n.o)) queue.push(nIdx);
                }
            });
        }
        return powered;
    }

    function startTimer() {
        clearInterval(timerId);
        timerId = setInterval(() => {
            if(!isLocked) { timeLeft--; document.getElementById('time-display').innerText = timeLeft; if(timeLeft <= 0) endGame(); }
        }, 1000);
    }

    function endGame() { isLocked = true; clearInterval(timerId); showOverlay("YOU ARE DEAD", "RETRY"); }

    function showOverlay(msg, btnTxt) {
        const o = document.getElementById('overlay'), t = document.getElementById('status-text'), b = document.getElementById('action-btn');
        t.innerText = msg; b.innerText = btnTxt;
        if(msg.includes("Congratulations")) { t.className = "stranger-text"; b.classList.add("hidden"); }
        else { t.className = (msg === "ALIVE") ? "alive-text" : "dead-text"; b.classList.remove("hidden"); }
        o.style.display = 'flex';
    }

    function handleBtnClick() { currentLvl = (document.getElementById('action-btn').innerText === "NEXT LEVEL") ? currentLvl+1 : 0; startGame(); }

    startGame();
</script>
</body>
</html>
