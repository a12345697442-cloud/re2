<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RE4 FINAL CALIBRATION</title>
    <style>
        :root {
            --re-green: #3cf08d;
            --re-dim: #1a3a26;
            --bg-black: #050806;
        }

        body {
            background-color: var(--bg-black); color: var(--re-green);
            font-family: 'Courier New', monospace;
            display: flex; flex-direction: column; align-items: center;
            margin: 0; height: 100vh; overflow: hidden;
            background-image: radial-gradient(circle, #0d1a12 0%, #000 100%);
        }

        #terminal {
            position: relative; width: 360px; height: 380px;
            margin-top: 20px; border: 2px solid var(--re-dim);
            background: rgba(0, 10, 5, 0.8);
        }

        canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }

        /* 符號按鈕樣式 */
        .node {
            position: absolute; width: 44px; height: 44px;
            display: flex; justify-content: center; align-items: center;
            z-index: 100; cursor: pointer; transition: transform 0.2s;
            -webkit-tap-highlight-color: transparent;
        }

        .node svg { width: 32px; height: 32px; fill: none; stroke: var(--re-dim); stroke-width: 3; }
        .node.on svg { stroke: var(--re-green); filter: drop-shadow(0 0 8px var(--re-green)); }

        /* 目標電源點 */
        .power-goal {
            position: absolute; width: 20px; height: 20px;
            border: 2px solid var(--re-dim); border-radius: 50%;
            display: flex; justify-content: center; align-items: center; z-index: 10;
        }
        .power-goal::after { content: '⚡'; font-size: 10px; opacity: 0.3; }
        .power-goal.active { border-color: #fff; box-shadow: 0 0 15px var(--re-green); background: var(--re-green); }
        .power-goal.active::after { opacity: 1; color: #000; }

        .power-tag { position: absolute; top: 15px; left: 15px; border: 1px solid var(--re-green); padding: 3px 8px; font-size: 12px; z-index: 20; }
        .counter { position: absolute; top: 15px; right: 15px; font-size: 14px; }
    </style>
</head>
<body>

    <div id="terminal">
        <div class="power-tag" id="main-power">POWER ▶▶</div>
        <div class="counter" id="status">0 / 4</div>
        <canvas id="circuitCanvas" width="360" height="380"></canvas>
    </div>

    <div style="margin-top:20px; font-size:12px; color:var(--re-dim);">INSUFFICIENT POWER. CALIBRATION REQUIRED.</div>

<script>
    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    // 定義方形電圈 (由外到內)
    const layers = [140, 100, 60, 20]; // 每個方形的半徑
    const nodes = [];
    const goals = [
        { x: 180, y: 80,  layer: 1, active: false },
        { x: 280, y: 190, layer: 0, active: false },
        { x: 180, y: 300, layer: 2, active: false },
        { x: 80,  y: 190, layer: 1, active: false }
    ];

    // 初始化節點 (放置在每一圈的十字交會點)
    function initNodes() {
        const types = ['T', 'L', 'CROSS', 'T', 'L', 'T', 'L', 'CROSS'];
        let id = 0;
        for (let l = 0; l < 3; l++) { // 3層可轉向節點
            const dist = layers[l];
            const positions = [
                {x: 180, y: 190-dist, d: 'N'}, {x: 180+dist, y: 190, d: 'E'},
                {x: 180, y: 190+dist, d: 'S'}, {x: 180-dist, y: 190, d: 'W'}
            ];
            positions.forEach(p => {
                const node = {
                    id: id++, x: p.x, y: p.y, layer: l,
                    type: types[id % types.length],
                    rot: Math.floor(Math.random() * 4) * 90,
                    powered: false
                };
                createNodeElement(node);
                nodes.push(node);
            });
        }
    }

    function createNodeElement(node) {
        const div = document.createElement('div');
        div.className = 'node';
        div.style.left = (node.x - 22) + 'px';
        div.style.top = (node.y - 22) + 'px';
        div.style.transform = `rotate(${node.rot}deg)`;
        div.innerHTML = `<svg viewBox="0 0 40 40">${getSVGPath(node.type)}</svg>`;
        div.onclick = () => {
            node.rot = (node.rot + 90) % 360;
            div.style.transform = `rotate(${node.rot}deg)`;
            if (window.navigator.vibrate) window.navigator.vibrate(20);
            updateGame();
        };
        node.el = div;
        document.getElementById('terminal').appendChild(div);
    }

    function getSVGPath(type) {
        if(type === 'L') return '<path d="M20 0 V20 H40" />';
        if(type === 'T') return '<path d="M0 20 H40 M20 20 V0" />';
        return '<path d="M20 0 V40 M0 20 H40" />'; // CROSS
    }

    function drawBaseGrid() {
        ctx.clearRect(0, 0, 360, 380);
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#1a3a26';
        ctx.lineWidth = 1;

        layers.forEach(r => {
            ctx.strokeRect(180 - r, 190 - r, r * 2, r * 2);
        });

        // 畫十字連接線
        ctx.beginPath();
        ctx.moveTo(180, 50); ctx.lineTo(180, 330);
        ctx.moveTo(40, 190); ctx.lineTo(320, 190);
        ctx.stroke();
    }

    function updateGame() {
        // 核心邏輯：從左上角 POWER (15, 15) 開始傳導
        // 為了簡化，我們模擬電力從最外圈順時針流動
        nodes.forEach(n => n.powered = false);
        
        // 模擬傳導算式：根據旋轉角度決定電力是否進入下一層
        let powerLevel = 0;
        nodes.forEach(n => {
            // 如果是 T 或 CROSS 且角度對準，則設為 powered
            if (n.rot % 180 === 0) n.powered = true;
            n.el.classList.toggle('on', n.powered);
        });

        // 更新目標點
        let activeGoals = 0;
        goals.forEach((g, i) => {
            // 檢查目標所在的圈層節點是否通電
            const relatedNode = nodes.find(n => n.layer === g.layer && n.powered);
            g.active = !!relatedNode;
            const el = document.getElementById(`goal-${i}`);
            el.classList.toggle('active', g.active);
            if(g.active) activeGoals++;
        });

        statusEl.innerText = `${activeGoals} / 4`;
        drawCurrent();
    }

    function drawCurrent() {
        drawBaseGrid();
        ctx.setLineDash([]);
        ctx.strokeStyle = '#3cf08d';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#3cf08d';

        // 從 POWER 標籤引出一條線
        ctx.beginPath();
        ctx.moveTo(75, 25); ctx.lineTo(180 - layers[0], 25); 
        ctx.lineTo(180 - layers[0], 190 - layers[0]);
        ctx.stroke();

        // 根據通電節點畫出發光方形
        nodes.forEach(n => {
            if(n.powered) {
                const r = layers[n.layer];
                ctx.strokeRect(180 - r, 190 - r, r * 2, r * 2);
            }
        });
    }

    function initGoals() {
        goals.forEach((g, i) => {
            const div = document.createElement('div');
            div.className = 'power-goal';
            div.id = `goal-${i}`;
            div.style.left = (g.x - 10) + 'px';
            div.style.top = (g.y - 10) + 'px';
            document.getElementById('terminal').appendChild(div);
        });
    }

    initNodes();
    initGoals();
    updateGame();
</script>
</body>
</html>
