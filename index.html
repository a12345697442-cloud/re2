<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修 - 完美分佈版</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: sans-serif; }
        canvas { background: #000; border: 2px solid #333; margin-top: 10px; }
    </style>
</head>
<body>
    <h3 style="color:#00ffcc">修正完成：紅框位於中點，電源位於角落，互不重疊</h3>
    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 定義關鍵座標常量 (與您提供的原型一致)
        const CX = 450; // 中心垂直線
        const CY = 425; // 中心水平線
        
        // 定義三層框 (x, y, w, h)
        const BOXES = [
            { x: 100, y: 100, w: 650, h: 650 }, // 外框 (BOX1)
            { x: 200, y: 200, w: 450, h: 450 }, // 中框 (BOX2)
            { x: 300, y: 300, w: 250, h: 250 }  // 內框 (BOX3)
        ];

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 左上角電池
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(50, 20, 150, 70);
            ctx.strokeStyle = "#00ffcc";
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 20, 150, 70);

            // 2. 電線佈局 (灰色虛線)
            ctx.strokeStyle = "#444";
            ctx.setLineDash([5, 8]);
            ctx.lineWidth = 2;

            ctx.beginPath();
            // 電池引線
            ctx.moveTo(200, 55); ctx.lineTo(CX, 55); ctx.lineTo(CX, BOXES[0].y);

            // 繪製三層方框
            BOXES.forEach(b => ctx.strokeRect(b.x, b.y, b.w, b.h));

            // 繪製十字軸
            ctx.moveTo(CX, 55); ctx.lineTo(CX, BOXES[0].y + BOXES[0].h); // 垂直
            ctx.moveTo(BOXES[0].x, CY); ctx.lineTo(BOXES[0].x + BOXES[0].w, CY); // 水平
            ctx.stroke();

            // 3. 放置紅色操作方格 (嚴格規則：每一圈4個，位於邊線中點)
            ctx.setLineDash([]);
            const nodes = [];
            
            BOXES.forEach(b => {
                // 上邊中點 (與垂直軸交會)
                nodes.push({x: CX, y: b.y});
                // 下邊中點 (與垂直軸交會)
                nodes.push({x: CX, y: b.y + b.h});
                // 左邊中點 (與水平軸交會)
                nodes.push({x: b.x, y: CY});
                // 右邊中點 (與水平軸交會)
                nodes.push({x: b.x + b.w, y: CY});
            });

            // 繪製紅框
            nodes.forEach(n => {
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50); // 50x50 的紅框
                
                // 畫個簡單的十字標記確認中心
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(n.x-5, n.y); ctx.lineTo(n.x+5, n.y); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(n.x, n.y-5); ctx.lineTo(n.x, n.y+5); ctx.stroke();
            });

            // 4. 放置電源點 (嚴格規則：位於角落，避開紅框)
            // 由於紅框都在「邊的中間」，我們把電源放在「角落」，絕對不會重疊
            const targets = [
                {x: CX, y: CY}, // 0. 絕對中心點 (這裡沒有放紅框，所以可以放電源)
                
                // 外圈的角落
                {x: BOXES[0].x, y: BOXES[0].y}, // 左上角
                {x: BOXES[0].x + BOXES[0].w, y: BOXES[0].y + BOXES[0].h}, // 右下角
                
                // 中圈的角落
                {x: BOXES[1].x + BOXES[1].w, y: BOXES[1].y}, // 右上角
                {x: BOXES[1].x, y: BOXES[1].y + BOXES[1].h}, // 左下角

                // 內圈的角落 (任選一個)
                {x: BOXES[2].x, y: BOXES[2].y} // 左上角
            ];

            targets.forEach(t => {
                ctx.strokeStyle = "#00ffcc";
                ctx.fillStyle = "#004433"; 
                
                ctx.beginPath(); 
                ctx.arc(t.x, t.y, 20, 0, Math.PI*2); // 畫圓
                ctx.fill();
                ctx.stroke();

                // 亮點
                ctx.fillStyle = "#00ffcc";
                ctx.beginPath(); ctx.arc(t.x, t.y, 5, 0, Math.PI*2); ctx.fill();
            });
        }

        drawMap();
    </script>
</body>
</html>
