<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCB NODE INSERTION</title>
    <style>
        :root { --green: #3cf08d; --bg: #050605; --dark: #1a251e; }
        body { background: var(--bg); color: var(--green); font-family: monospace; display: flex; flex-direction: column; align-items: center; margin: 0; }
        
        #ui { width: 340px; margin-top: 20px; display: flex; justify-content: space-between; border-bottom: 1px solid var(--dark); padding: 5px; }
        #board { position: relative; width: 360px; height: 360px; background: #000; border: 2px solid #222; margin-top: 10px; }
        canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }

        /* 插槽 */
        .socket {
            position: absolute; width: 44px; height: 44px; background: #111; 
            border: 2px dashed #444; border-radius: 4px; z-index: 10;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
        }
        .socket.filled { border-style: solid; border-color: #666; }
        .socket svg { width: 34px; height: 34px; stroke: #444; stroke-width: 5; fill: none; }
        .socket.powered svg { stroke: var(--green); filter: drop-shadow(0 0 5px var(--green)); }

        /* 電源目標 */
        .cell {
            position: absolute; width: 14px; height: 14px; border: 2px solid #333;
            border-radius: 50%; z-index: 50; background: #000;
        }
        .cell.lit { background: var(--green); border-color: #fff; box-shadow: 0 0 15px var(--green); }

        /* 插件選單 */
        #inventory { 
            width: 340px; margin-top: 20px; display: flex; gap: 10px; 
            background: #111; padding: 15px; border: 1px solid var(--dark);
        }
        .inv-item {
            width: 50px; height: 50px; border: 2px solid #444; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; background: #000;
        }
        .inv-item.selected { border-color: var(--green); background: var(--dark); }
        .inv-item svg { width: 25px; height: 25px; stroke: var(--green); stroke-width: 4; fill: none; }
        .inv-count { font-size: 10px; margin-top: 2px; }
    </style>
</head>
<body>

<div id="ui">
    <div>STAGE: <span style="color:#ffcc00">INSERTION MODE</span></div>
    <div id="stat">NODES: 0 / 4</div>
</div>

<div id="board">
    <canvas id="cvs" width="360" height="360"></canvas>
    <div style="position:absolute; left:165px; top:-5px; font-size:10px;">[POWER IN]</div>
</div>

<div id="inventory">
    <div class="inv-item" onclick="selectPart('L')" id="partL">
        <svg viewBox="0 0 40 40"><path d="M20 5 V20 H35" /></svg>
        <span class="inv-count">L (x2)</span>
    </div>
    <div class="inv-item" onclick="selectPart('T')" id="partT">
        <svg viewBox="0 0 40 40"><path d="M5 20 H35 M20 20 V5" /></svg>
        <span class="inv-count">T (x1)</span>
    </div>
    <div class="inv-item" onclick="selectPart('CROSS')" id="partX">
        <svg viewBox="0 0 40 40"><path d="M5 20 H35 M20 5 V35" /></svg>
        <span class="inv-count">X (x1)</span>
    </div>
    <button style="margin-left:auto; background:#000; border:1px solid #666; color:#888;" onclick="resetBoard()">RESET</button>
</div>

<script>
const board = document.getElementById('board');
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');

let selectedPart = null;
let partsCount = { L: 2, T: 1, CROSS: 1 };

const sockets = [
    { id: 0, x: 180, y: 80, part: null, rot: 0 },
    { id: 1, x: 80,  y: 180, part: null, rot: 0 },
    { id: 2, x: 280, y: 180, part: null, rot: 0 }
];

const cells = [
    { x: 30, y: 180, r: 1 }, { x: 180, y: 280, r: 0 }, { x: 330, y: 180, r: 2 }
];

const wires = [
    { from: [180, 0], to: [180, 80], powered: true },
    { from: [180, 80], to: [80, 80], pId: 0, req: 'left' },
    { from: [80, 80], to: [80, 180], pId: 0, req: 'left' },
    { from: [180, 80], to: [280, 80], pId: 0, req: 'right' },
    { from: [280, 80], to: [280, 180], pId: 0, req: 'right' },
    { from: [180, 80], to: [180, 280], pId: 0, req: 'down' },
    { from: [80, 180], to: [30, 180], pId: 1, req: 'left' },
    { from: [280, 180], to: [330, 180], pId: 2, req: 'right' }
];

function selectPart(type) {
    if (partsCount[type] <= 0) return;
    selectedPart = type;
    document.querySelectorAll('.inv-item').forEach(el => el.classList.remove('selected'));
    document.getElementById('part' + (type==='CROSS'?'X':type)).classList.add('selected');
}

function init() {
    sockets.forEach(s => {
        const div = document.createElement('div');
        div.className = 'socket';
        div.style.left = (s.x - 22) + 'px';
        div.style.top = (s.y - 22) + 'px';
        div.onclick = () => handleSocketClick(s, div);
        s.el = div;
        board.appendChild(div);
    });

    cells.forEach(c => {
        const div = document.createElement('div');
        div.className = 'cell';
        div.style.left = (c.x - 7) + 'px';
        div.style.top = (c.y - 7) + 'px';
        c.el = div;
        board.appendChild(div);
    });
    update();
}

function handleSocketClick(s, el) {
    if (!s.part && selectedPart) {
        s.part = selectedPart;
        partsCount[selectedPart]--;
        selectedPart = null;
        updateUI();
    } else if (s.part) {
        s.rot = (s.rot + 90) % 360;
    }
    update();
}

function update() {
    // 傳導邏輯
    wires.forEach(w => {
        if (w.pId === undefined) return;
        const s = sockets[w.pId];
        w.powered = false;
        if (s.part) {
            // 簡化邏輯：如果有零件且轉向正確則導通
            if (s.part === 'T' && (s.rot === 180 || s.rot === 90)) w.powered = true;
            if (s.part === 'CROSS') w.powered = true;
            if (s.part === 'L' && s.rot === 270 && w.req === 'left') w.powered = true;
        }
    });

    // 更新視覺
    sockets.forEach(s => {
        if (s.part) {
            s.el.classList.add('filled');
            s.el.classList.toggle('powered', s.id === 0 || wires.some(w => w.powered && w.to[0] === s.x));
            s.el.style.transform = `rotate(${s.rot}deg)`;
            s.el.innerHTML = `<svg viewBox="0 0 40 40">${getSVG(s.part)}</svg>`;
        }
    });

    let score = 0;
    cells.forEach(c => {
        const lit = wires.some(w => w.powered && w.to[0] === c.x && w.to[1] === c.y);
        c.el.classList.toggle('lit', lit);
        if (lit) score++;
    });
    document.getElementById('stat').innerText = `NODES: ${score} / 3`;
    draw();
}

function getSVG(t) {
    if(t === 'L') return '<path d="M20 5 V20 H35" />';
    if(t === 'T') return '<path d="M5 20 H35 M20 20 V5" />';
    return '<path d="M5 20 H35 M20 5 V35" />';
}

function updateUI() {
    document.querySelectorAll('.inv-item').forEach(el => el.classList.remove('selected'));
    document.getElementById('partL').querySelector('.inv-count').innerText = `L (x${partsCount.L})`;
    document.getElementById('partT').querySelector('.inv-count').innerText = `T (x${partsCount.T})`;
    document.getElementById('partX').querySelector('.inv-count').innerText = `X (x${partsCount.CROSS})`;
}

function resetBoard() {
    sockets.forEach(s => { s.part = null; s.rot = 0; s.el.innerHTML = ''; s.el.classList.remove('filled','powered'); });
    partsCount = { L: 2, T: 1, CROSS: 1 };
    updateUI(); update();
}

function draw() {
    ctx.clearRect(0,0,360,360);
    wires.forEach(w => {
        ctx.beginPath(); ctx.moveTo(w.from[0], w.from[1]); ctx.lineTo(w.to[0], w.to[1]);
        ctx.strokeStyle = w.powered ? '#3cf08d' : '#222';
        ctx.lineWidth = 4; ctx.stroke();
    });
}

init();
</script>
</body>
</html>
