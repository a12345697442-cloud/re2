<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修專家 - 三關挑戰</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        #ui-layer { position: absolute; top: 10px; width: 100%; pointer-events: none; }
        .stat-box { display: inline-block; margin: 0 20px; font-size: 24px; color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); 
                   display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        button { padding: 15px 30px; font-size: 20px; background: #00ffcc; border: none; cursor: pointer; border-radius: 5px; font-weight: bold; }
        canvas { background: #000; border: 2px solid #333; cursor: pointer; display: block; margin: 10px auto; box-shadow: 0 0 30px #001100; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">關卡: <span id="level-txt">1</span> / 3</div>
        <div class="stat-box">時間: <span id="timer-txt">60</span>s</div>
        <div class="stat-box">狀態: <span id="status-txt">電力中斷</span></div>
    </div>

    <div id="overlay">
        <h1 id="msg-title" style="color:#00ffcc; font-size: 48px;"></h1>
        <p id="msg-desc" style="font-size: 20px; margin-bottom: 20px;"></p>
        <button id="action-btn" onclick="handleAction()">開始遊戲</button>
    </div>

    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 介面元素
        const levelTxt = document.getElementById('level-txt');
        const timerTxt = document.getElementById('timer-txt');
        const statusTxt = document.getElementById('status-txt');
        const overlay = document.getElementById('overlay');
        const msgTitle = document.getElementById('msg-title');
        const msgDesc = document.getElementById('msg-desc');
        const actionBtn = document.getElementById('action-btn');

        const CX = 400; 
        const CY = 480; 
        const BOX_SIZES = [600, 460, 320, 180]; 
        
        let currentLevel = 1;
        let timeLeft = 60;
        let gameActive = false;
        let timerInterval;

        let nodes = [];
        let segments = [];
        let targets = [];

        // --- 1. 初始化關卡 ---
        function initLevel(lv) {
            nodes = [];
            segments = [];
            targets = [];
            timeLeft = 60;
            updateUI();

            // 建立 16 個節點
            BOX_SIZES.forEach((size, i) => {
                const half = size / 2;
                const layerNum = 4 - i; 

                // 關卡難度設定
                let typePool = ['T'];
                if (lv === 2) typePool = ['T', 'L', 'T']; 
                if (lv === 3) typePool = ['T', 'L', 'S']; // S 代表黃色雙彎道 (Straight/Snake)

                const directions = ['T', 'R', 'B', 'L'];
                directions.forEach((dir, dIdx) => {
                    let type = typePool[Math.floor(Math.random() * typePool.length)];
                    let x = CX, y = CY;
                    if(dir === 'T') y -= half;
                    else if(dir === 'R') x += half;
                    else if(dir === 'B') y += half;
                    else x -= half;

                    nodes.push({
                        id: `L${i}_${dir}`,
                        layer: i,
                        x: x, y: y,
                        type: type,
                        rot: 0, // 初始旋轉
                        display: layerNum,
                        powered: false
                    });
                });
            });

            // 建立連線 (固定結構)
            setupBaseSegments();
            
            // 打亂畫面：持續旋轉直到「初始電力為 0」且「角度隨機」
            scrambleUntilDark();

            gameActive = true;
            startTimer();
        }

        function setupBaseSegments() {
            addSegment('SOURCE', 'L0_T', [[CX, 70], [CX, CY - 300]]);
            for(let i=0; i<3; i++) {
                addSegment(`L${i}_T`, `L${i+1}_T`, [[CX, CY-BOX_SIZES[i]/2], [CX, CY-BOX_SIZES[i+1]/2]]);
                addSegment(`L${i}_B`, `L${i-1}_B`, [[CX, CY+BOX_SIZES[i]/2], [CX, CY+BOX_SIZES[i-1]/2]]);
                addSegment(`L${i}_L`, `L${i+1}_L`, [[CX-BOX_SIZES[i]/2, CY], [CX-BOX_SIZES[i+1]/2, CY]]);
                addSegment(`L${i}_R`, `L${i-1}_R`, [[CX+BOX_SIZES[i]/2, CY], [CX+BOX_SIZES[i-1]/2, CY]]);
            }
            addSegment('L3_T', 'L3_B', [[CX, CY-90], [CX, CY+90]]);
            addSegment('L3_L', 'L3_R', [[CX-90, CY], [CX+90, CY]]);
            BOX_SIZES.forEach((size, i) => {
                const h = size/2;
                addSegment(`L${i}_T`, `L${i}_R`, [[CX, CY-h], [CX+h, CY-h], [CX+h, CY]]);
                addSegment(`L${i}_R`, `L${i}_B`, [[CX+h, CY], [CX+h, CY+h], [CX, CY+h]]);
                addSegment(`L${i}_B`, `L${i}_L`, [[CX, CY+h], [CX-h, CY+h], [CX-h, CY]]);
                addSegment(`L${i}_L`, `L${i}_T`, [[CX-h, CY], [CX-h, CY-h], [CX, CY-h]]);
            });
            targets = [
                { x: CX + 300, y: CY - 300, segIdx: findSegIndex('L0_T', 'L0_R') },
                { x: CX - 300, y: CY + 300, segIdx: findSegIndex('L0_B', 'L0_L') },
                { x: CX + 230, y: CY + 230, segIdx: findSegIndex('L1_R', 'L1_B') },
                { x: CX - 160, y: CY - 160, segIdx: findSegIndex('L2_L', 'L2_T') },
                { x: CX + 90, y: CY - 90, segIdx: findSegIndex('L3_T', 'L3_R') },
                { x: CX, y: CY, segIdx: findSegIndex('L3_L', 'L3_R') }
            ];
        }

        function scrambleUntilDark() {
            let limit = 0;
            do {
                nodes.forEach(n => {
                    if (Math.random() > 0.5) n.rot = Math.floor(Math.random() * 4);
                });
                calculatePower();
                limit++;
            } while (segments.some(s => s.powered) && limit < 100); 
        }

        function addSegment(id1, id2, points) { segments.push({ from: id1, to: id2, points: points, powered: false }); }
        function findSegIndex(id1, id2) { return segments.findIndex(s => (s.from===id1 && s.to===id2) || (s.from===id2 && s.to===id1)); }

        // --- 2. 電力傳導邏輯 (包含黃色符號) ---
        function calculatePower() {
            nodes.forEach(n => n.powered = false);
            segments.forEach(s => s.powered = false);
            targets.forEach(t => t.powered = false);

            let queue = ['SOURCE']; 
            let firstSeg = segments.find(s => s.from === 'SOURCE');
            if(firstSeg) { firstSeg.powered = true; queue.push(firstSeg.to); }

            while(queue.length > 0) {
                let currId = queue.shift();
                let currNode = nodes.find(n => n.id === currId);
                if (!currNode) continue;
                currNode.powered = true;

                let ports = [];
                if (currNode.type === 'T') {
                    let block = (currNode.rot + 2) % 4; 
                    for(let d=0; d<4; d++) if(d !== block) ports.push(d);
                } else if (currNode.type === 'L') {
                    ports.push(currNode.rot, (currNode.rot + 1) % 4);
                } else if (currNode.type === 'S') { // 黃色雙彎道
                    // 假設 S 型是直通對向：(rot) 與 (rot+2)%4
                    ports.push(currNode.rot, (currNode.rot + 2) % 4);
                }

                segments.forEach(seg => {
                    if (seg.from !== currId && seg.to !== currId) return;
                    let neighborId = (seg.from === currId) ? seg.to : seg.from;
                    let neighborNode = nodes.find(n => n.id === neighborId);
                    
                    let dx = 0, dy = 0;
                    if (neighborNode) { dx = neighborNode.x - currNode.x; dy = neighborNode.y - currNode.y; }
                    else if (neighborId === 'SOURCE') { dx = 0; dy = -1; }

                    let dir = (Math.abs(dy) > Math.abs(dx)) ? (dy < 0 ? 0 : 2) : (dx > 0 ? 1 : 3);

                    if (ports.includes(dir) && !seg.powered) {
                        seg.powered = true;
                        if (neighborNode) {
                            let nPorts = [];
                            if (neighborNode.type === 'T') { for(let d=0; d<4; d++) if(d !== (neighborNode.rot + 2) % 4) nPorts.push(d); }
                            else if (neighborNode.type === 'L') { nPorts.push(neighborNode.rot, (neighborNode.rot + 1) % 4); }
                            else if (neighborNode.type === 'S') { nPorts.push(neighborNode.rot, (neighborNode.rot + 2) % 4); }
                            
                            if (nPorts.includes((dir + 2) % 4)) queue.push(neighborId);
                        }
                    }
                });
            }

            targets.forEach(t => t.powered = segments[t.segIdx].powered);
            checkWin();
        }

        // --- 3. 遊戲流程控制 ---
        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gameActive) return;
                timeLeft--;
                timerTxt.innerText = timeLeft;
                if (timeLeft <= 0) gameOver(false);
            }, 1000);
        }

        function checkWin() {
            const allLit = targets.every(t => t.powered);
            if (allLit && gameActive) {
                gameActive = false;
                clearInterval(timerInterval);
                setTimeout(() => {
                    if (currentLevel < 3) {
                        showOverlay("關卡完成！", `成功修復第 ${currentLevel} 區電力`, "進入下一關");
                    } else {
                        showOverlay("全系統修復！", "你已成為頂級電路工程師", "重新開始");
                    }
                }, 500);
            }
        }

        function gameOver(win) {
            gameActive = false;
            clearInterval(timerInterval);
            showOverlay("電力過載！", "時間耗盡，請重新嘗試", "重試本關");
        }

        function showOverlay(title, desc, btnText) {
            msgTitle.innerText = title;
            msgDesc.innerText = desc;
            actionBtn.innerText = btnText;
            overlay.style.display = 'flex';
        }

        function handleAction() {
            overlay.style.display = 'none';
            if (msgTitle.innerText === "全系統修復！") {
                currentLevel = 1;
            } else if (msgTitle.innerText === "關卡完成！") {
                currentLevel++;
            }
            initLevel(currentLevel);
        }

        function updateUI() {
            levelTxt.innerText = currentLevel;
            statusTxt.innerText = "電力掃描中...";
        }

        // --- 4. 繪圖與互動 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 繪製電池、線路、目標 (同前版)
            ctx.fillStyle = "#1a1a1a"; ctx.fillRect(CX - 50, 20, 100, 50);
            ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.strokeRect(CX - 50, 20, 100, 50);
            ctx.fillStyle = "#00ffcc"; ctx.font = "bold 16px Arial"; ctx.fillText("POWER", CX - 30, 52);

            segments.forEach(seg => {
                ctx.beginPath();
                ctx.strokeStyle = seg.powered ? "#00ffcc" : "#333";
                ctx.setLineDash(seg.powered ? [] : [5, 8]);
                ctx.lineWidth = seg.powered ? 3 : 2;
                ctx.moveTo(seg.points[0][0], seg.points[0][1]);
                for(let i=1; i<seg.points.length; i++) ctx.lineTo(seg.points[i][0], seg.points[i][1]);
                ctx.stroke();
            });

            targets.forEach(t => {
                ctx.beginPath(); ctx.fillStyle = t.powered ? "#00ff00" : "#003311";
                ctx.arc(t.x, t.y, 20, 0, Math.PI*2); ctx.fill();
            });

            nodes.forEach(n => {
                ctx.strokeStyle = "red"; ctx.lineWidth = 2; ctx.setLineDash([]);
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50);
                ctx.fillStyle = "#ff5555"; ctx.font = "bold 12px Arial";
                ctx.fillText(n.display, n.x + 15, n.y - 15);

                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.rot * Math.PI / 2);
                ctx.strokeStyle = n.powered ? "#ffffff" : (n.type === 'S' ? "#ffcc00" : "#0055aa");
                ctx.lineWidth = 4; ctx.beginPath();
                if (n.type === 'T') { ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.moveTo(0, 0); ctx.lineTo(0, -15); }
                else if (n.type === 'L') { ctx.moveTo(0, -15); ctx.lineTo(0, 0); ctx.lineTo(15, 0); }
                else if (n.type === 'S') { ctx.moveTo(0, -15); ctx.lineTo(0, 15); } // 黃色直線雙向
                ctx.stroke();
                ctx.restore();
            });
            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            if (!gameActive) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            let clickedLayer = -1;
            for (let n of nodes) {
                if (mx > n.x - 25 && mx < n.x + 25 && my > n.y - 25 && my < n.y + 25) {
                    clickedLayer = n.layer;
                    break;
                }
            }
            if (clickedLayer !== -1) {
                nodes.forEach(n => { if (n.layer === clickedLayer) n.rot = (n.rot + 1) % 4; });
                calculatePower();
            }
        });

        showOverlay("維修任務開始", "接通所有區域電力，時間 60 秒", "開始第一關");
        draw();
    </script>
</body>
</html>

