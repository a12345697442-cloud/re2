<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修專家 - 究極三關版</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        
        /* 介面樣式 */
        #ui-bar { 
            position: absolute; top: 0; left: 0; width: 100%; height: 60px; 
            background: rgba(0, 20, 10, 0.9); border-bottom: 1px solid #00ffcc;
            display: flex; justify-content: center; align-items: center; gap: 30px;
            pointer-events: none; z-index: 10;
        }
        .stat-box { font-size: 20px; color: #00ffcc; text-shadow: 0 0 5px #00ffcc; font-weight: bold; }
        .stat-value { color: #fff; margin-left: 10px; }
        .warning { color: #ff3333; animation: pulse 1s infinite; }

        /* 彈窗樣式 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            backdrop-filter: blur(5px);
        }
        h1 { color: #00ffcc; font-size: 48px; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 20px #00ffcc; }
        p { font-size: 18px; color: #aaa; margin-bottom: 30px; max-width: 600px; line-height: 1.6; }
        button {
            padding: 15px 40px; font-size: 24px; color: #000; background: #00ffcc;
            border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 15px #00ffcc; transition: transform 0.2s;
        }
        button:hover { transform: scale(1.1); background: #fff; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        canvas { background: #000; border: 2px solid #333; cursor: pointer; display: block; margin: 60px auto 0; box-shadow: 0 0 30px #001100; }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div class="stat-box">LEVEL <span id="level-disp" class="stat-value">1 / 3</span></div>
        <div class="stat-box">TIME <span id="time-disp" class="stat-value">60</span></div>
        <div class="stat-box">STATUS <span id="status-disp" class="stat-value" style="color:#ff3333">斷線</span></div>
    </div>

    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <div id="overlay">
        <h1 id="overlay-title">電路維修專家</h1>
        <p id="overlay-desc">
            歡迎來到電力中樞。<br>
            你需要通過 3 個難度遞增的關卡。<br>
            點擊紅框數字可旋轉該層所有線路。<br>
            <span style="color:#ffff00">注意：Level 3 將出現黃色特殊線路。</span>
        </p>
        <button id="overlay-btn" onclick="startGame()">開始挑戰</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelDisp = document.getElementById('level-disp');
        const timeDisp = document.getElementById('time-disp');
        const statusDisp = document.getElementById('status-disp');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayDesc = document.getElementById('overlay-desc');
        const overlayBtn = document.getElementById('overlay-btn');

        const CX = 400; 
        const CY = 480; 
        const BOX_SIZES = [600, 460, 320, 180]; 

        // 遊戲狀態
        let currentLevel = 1;
        let timeLeft = 60;
        let timerInterval = null;
        let isPlaying = false;
        
        let nodes = [];
        let segments = [];
        let targets = [];

        // --- 1. 關卡設定 ---
        function getLevelConfig(level) {
            switch(level) {
                case 1: // 簡單：只有 T 型
                    return { types: ['T'], scrambleRange: [1, 2] };
                case 2: // 中等：T + L 型
                    return { types: ['T', 'L'], scrambleRange: [1, 3] };
                case 3: // 困難：T + L + 黃色一字型 (I)
                    return { types: ['T', 'L', 'I'], scrambleRange: [2, 4] }; 
                default:
                    return { types: ['T'], scrambleRange: [1, 1] };
            }
        }

        // --- 2. 遊戲流程控制 ---
        function startGame() {
            currentLevel = 1;
            startLevel(currentLevel);
        }

        function nextLevel() {
            currentLevel++;
            if (currentLevel > 3) {
                showOverlay("任務完成", "恭喜！你是真正的電路大師。<br>所有電力系統已恢復正常。", "重新挑戰", startGame);
            } else {
                startLevel(currentLevel);
            }
        }

        function startLevel(level) {
            // UI 更新
            overlay.style.display = 'none';
            levelDisp.innerText = `${level} / 3`;
            timeLeft = 60;
            timeDisp.innerText = timeLeft;
            timeDisp.className = "stat-value";
            isPlaying = true;

            // 初始化地圖
            initGameMap(level);
            
            // 啟動計時器
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!isPlaying) return;
                timeLeft--;
                timeDisp.innerText = timeLeft;
                
                if (timeLeft <= 10) timeDisp.className = "stat-value warning";

                if (timeLeft <= 0) {
                    gameOver();
                }
            }, 1000);
        }

        function gameOver() {
            isPlaying = false;
            clearInterval(timerInterval);
            showOverlay("電力中斷", `時間耗盡！挑戰在 Level ${currentLevel} 失敗了。<br>請重新來過。`, "再試一次", startGame);
        }

        function showOverlay(title, desc, btnText, callback) {
            overlayTitle.innerText = title;
            overlayTitle.innerHTML = title; // 支援 HTML 顏色
            overlayDesc.innerHTML = desc;
            overlayBtn.innerText = btnText;
            overlayBtn.onclick = callback;
            overlay.style.display = 'flex';
        }

        // --- 3. 地圖生成與通關保證 ---
        function initGameMap(level) {
            const config = getLevelConfig(level);
            let attempt = 0;
            
            // 強制迴圈：直到生成的初始盤面是「全暗」的
            do {
                generateSolvedState(config.types);
                scrambleBoard(config.scrambleRange);
                calculatePower(); // 計算當前電力
                attempt++;
                // 檢查是否有任何目標被點亮 (偷跑)
                let anyLit = targets.some(t => t.powered);
                if (!anyLit) break; // 成功：全暗
            } while (attempt < 100);

            draw();
        }

        function generateSolvedState(allowedTypes) {
            nodes = [];
            segments = [];
            targets = [];

            // A. 生成基礎節點 (先全部設為導通狀態的 T 型，稍後替換類型)
            // 為了保證有解，我們先建立一個「完美通路」
            BOX_SIZES.forEach((size, i) => {
                const half = size / 2;
                const layerNum = 4 - i;

                // 隨機從允許的類型中挑選，但必須確保 "winRot" (正確答案角度) 能導通主幹
                // 這裡簡化：我們先建立節點物件，winRot 固定為導通軸線的方向
                // T型導通軸線：
                // Top Node (垂直軸): 需要 Up(0) + Down(2)。T型(1) 連接 Left, Up, Down(X? No T points 1=Right).
                // T型定義：rot指向凸出端。缺口在 (rot+2)%4。
                // 垂直導通需要 Up(0) & Down(2). 
                // T(1): ports 0,1,3 (Up, Right, Left). No Down. X
                // T(0): ports 3,0,1 (Left, Up, Right). No Down. X
                // T(3): ports 2,3,0 (Down, Left, Up). YES! rot=3 (指向左) 缺口在右，通上下。
                // T(1): ports 0,1,2 (Up, Right, Down). YES! rot=1 (指向右) 缺口在左，通上下。
                
                // 定義 WinRot (正確答案)
                // Top Node (需通上下): T用1或3。L用(impossible for straight)。I用0。
                // Right Node (需通左右): T用0或2。L用(impossible)。I用1。
                
                // 為了增加隨機性，我們會在 "能導通" 的選項中隨機挑
                
                // Helper to pick type
                const pickType = () => allowedTypes[Math.floor(Math.random() * allowedTypes.length)];

                // 建立節點函數
                const addNode = (id, x, y, requiredAxis) => { // axis: 'V'ertical or 'H'orizontal
                    let type = pickType();
                    let winRot = 0;

                    // 針對不同符號，設定能導通的 winRot
                    if (type === 'I') { // 黃色一字
                        // I型：0=垂直(通上下), 1=水平(通左右)
                        winRot = (requiredAxis === 'V') ? 0 : 1;
                    } else if (type === 'L') {
                        // L型無法直線導通，這會導致無解嗎？
                        // 不，L型可以轉彎。但在這個簡化版的 "軸線導通" 邏輯裡，如果主軸用了 L，電就斷了。
                        // *** 關鍵修正 ***：如果在主軸位置隨機到了 L 型，我們必須強制把它變回 T 或 I，或者設計彎曲路徑。
                        // 為了保持通關性邏輯簡單，我们在 "主軸節點" (與十字線相交的點) 強制排除 L 型，除非是 Level 2/3 的特殊設計。
                        // 但為了讓 L 型出現，我們允許 L 型，但它必須是 "轉折點" 嗎？
                        // 為了簡化：我們讓主軸節點只能是 T 或 I (如果有 I)。L 型只出現在非主軸？
                        // 不，這樣 L 型就沒戲份了。
                        // **解決方案**：我們的 "完美狀態" 不一定是直線！
                        // 但為了程式好寫，我們假定完美狀態就是直線貫通。
                        // 所以：如果隨機到 L，就重抽，直到抽到 T 或 I。
                        // 這樣 Level 2 就沒有 L 了？ 
                        // -> 我們可以在 Level 2 把 "目標" 放在角落，這需要 L 型！
                        // -> 沒錯，角落連接依賴的是 Segment 的 'corner' 屬性，而不是節點本身。
                        // -> 節點本身是在邊的中點。
                        // -> OK, 如果節點在邊中點，它必須直線通過才能連到下一層。
                        // -> 所以：邊中點的節點如果是 L，它會把電導向 "環狀線" 而不是 "下一層"。
                        // -> 這也是一種解法！
                        // -> 但為了確保最基礎的通關，我們先強制主軸用 T 或 I。
                        // -> 等等，Level 2 只有 T 和 L。如果強制主軸不用 L，那 Level 2 就跟 Level 1 一樣了。
                        // -> 懂了。Level 2 的難點在於：你需要把電 "轉出去" 再 "轉回來"？這太複雜。
                        // -> **妥協**：我們讓 L 型可以出現在主軸，但這代表該層的電會斷在這一層，轉而流向左右。
                        // -> 只要最終能流到角落的目標即可！
                        // -> 角落目標需要：Top節點往右流，Right節點往上流。
                        // -> 這正是 L 型的強項！
                        // -> 所以：Top Node 可以是 L (WinRot 連接 Up & Right)。
                        
                        // 讓我們設定一套 "混合" 的 WinRot 策略
                        // 策略：所有 Top Node 的 WinRot 設定為 "連接 Up & Down" (穿透) 或者 "連接 Up & Right" (轉彎給目標)
                        
                        // 簡化版通關路徑：
                        // 1. 十字軸全部直線貫通 (使用 T 或 I) -> 供給中心電力。
                        // 2. 每個節點同時嘗試供給角落的目標。
                        
                        if (requiredAxis === 'V') { // Top / Bottom
                            // 優先嘗試直線
                            if (Math.random() > 0.3 || type === 'L') { 
                                // 70% 機率直線 (L型除外，L無法直線)
                                if (type === 'L') type = 'T'; // 強制轉 T 以保證主軸不斷
                                winRot = (type === 'I') ? 0 : 1; // T用1(右)通上下
                            }
                        } else { // Left / Right
                            if (Math.random() > 0.3 || type === 'L') {
                                if (type === 'L') type = 'T';
                                winRot = (type === 'I') ? 1 : 2; // T用2(下)通左右
                            }
                        }
                    } else { // T type
                        winRot = (requiredAxis === 'V') ? 1 : 2; 
                    }
                    
                    // 特殊：如果是 Level 3，且抽到了 I，那就保留 I
                    // 如果 Level 2，抽到 L，但上面邏輯把它轉 T 了。
                    // 為了讓 L 出現，我們隨機把某些節點設為 L，並設定它的 WinRot 為 "轉向角落"
                    if (allowedTypes.includes('L') && Math.random() > 0.6) {
                        type = 'L';
                        // Top Node: Up(0) + Right(1) -> Rot 0
                        // Right Node: Right(1) + Down(2) -> Rot 1
                        // Bottom Node: Down(2) + Left(3) -> Rot 2
                        // Left Node: Left(3) + Up(0) -> Rot 3
                        if (id.includes('_T')) winRot = 0;
                        if (id.includes('_R')) winRot = 1;
                        if (id.includes('_B')) winRot = 2;
                        if (id.includes('_L')) winRot = 3;
                    }

                    nodes.push({ id: id, layer: i, x: x, y: y, type: type, rot: winRot, winRot: winRot, display: layerNum, powered: false });
                };

                addNode(`L${i}_T`, CX, CY - half, 'V');
                addNode(`L${i}_R`, CX + half, CY, 'H');
                addNode(`L${i}_B`, CX, CY + half, 'V');
                addNode(`L${i}_L`, CX - half, CY, 'H');
            });

            // B. 建立線路 (Segments) - 物理連接
            const addSeg = (id1, id2, pts) => segments.push({ from: id1, to: id2, points: pts, powered: false });

            // Source -> L0_T
            addSeg('SOURCE', 'L0_T', [[CX, 70], [CX, CY - 300]]);
            
            // 軸線連接
            for(let i=0; i<3; i++) {
                addSeg(`L${i}_T`, `L${i+1}_T`, [[CX, CY-BOX_SIZES[i]/2], [CX, CY-BOX_SIZES[i+1]/2]]);
                addSeg(`L${i}_B`, `L${i-1}_B`, [[CX, CY+BOX_SIZES[i]/2], [CX, CY+BOX_SIZES[i-1]/2]]);
                addSeg(`L${i}_L`, `L${i+1}_L`, [[CX-BOX_SIZES[i]/2, CY], [CX-BOX_SIZES[i+1]/2, CY]]);
                addSeg(`L${i}_R`, `L${i-1}_R`, [[CX+BOX_SIZES[i]/2, CY], [CX+BOX_SIZES[i-1]/2, CY]]);
            }
            // 中心穿透
            addSeg('L3_T', 'L3_B', [[CX, CY-90], [CX, CY+90]]);
            addSeg('L3_L', 'L3_R', [[CX-90, CY], [CX+90, CY]]);

            // 環狀連接 (角落)
            BOX_SIZES.forEach((size, i) => {
                const h = size/2;
                addSeg(`L${i}_T`, `L${i}_R`, [[CX, CY-h], [CX+h, CY-h], [CX+h, CY]]);
                addSeg(`L${i}_R`, `L${i}_B`, [[CX+h, CY], [CX+h, CY+h], [CX, CY+h]]);
                addSeg(`L${i}_B`, `L${i}_L`, [[CX, CY+h], [CX-h, CY+h], [CX-h, CY]]);
                addSeg(`L${i}_L`, `L${i}_T`, [[CX-h, CY], [CX-h, CY-h], [CX, CY-h]]);
            });

            // C. 配置電源目標
            const findSeg = (id1, id2) => segments.findIndex(s => (s.from===id1 && s.to===id2) || (s.from===id2 && s.to===id1));
            
            // 6個目標位置
            targets.push({ x: CX + 300, y: CY - 300, segIdx: findSeg('L0_T', 'L0_R'), powered: false });
            targets.push({ x: CX - 300, y: CY + 300, segIdx: findSeg('L0_B', 'L0_L'), powered: false });
            targets.push({ x: CX + 230, y: CY + 230, segIdx: findSeg('L1_R', 'L1_B'), powered: false });
            targets.push({ x: CX - 160, y: CY - 160, segIdx: findSeg('L2_L', 'L2_T'), powered: false });
            targets.push({ x: CX + 90, y: CY - 90, segIdx: findSeg('L3_T', 'L3_R'), powered: false });
            targets.push({ x: CX, y: CY, segIdx: findSeg('L3_L', 'L3_R'), powered: false });
        }

        function scrambleBoard(range) {
            for(let layer=0; layer<4; layer++) {
                // 隨機轉動 N 次 (1~3)
                let moves = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
                nodes.forEach(n => {
                    if (n.layer === layer) {
                        n.rot = (n.rot + moves) % 4;
                    }
                });
            }
        }

        // --- 4. 核心電力運算 (升級版) ---
        function calculatePower() {
            nodes.forEach(n => n.powered = false);
            segments.forEach(s => s.powered = false);
            targets.forEach(t => t.powered = false);

            let queue = ['SOURCE']; 
            // Source 直接供電給第一條線
            let firstSeg = segments.find(s => s.from === 'SOURCE');
            if(firstSeg) { firstSeg.powered = true; queue.push(firstSeg.to); }

            while(queue.length > 0) {
                let currId = queue.shift();
                let currNode = nodes.find(n => n.id === currId);
                if (!currNode) continue;

                currNode.powered = true;

                // 取得該節點當前導通的端口 (Ports)
                // 0:Up, 1:Right, 2:Down, 3:Left
                let ports = [];
                if (currNode.type === 'T') {
                    let block = (currNode.rot + 2) % 4; // T缺口
                    for(let d=0; d<4; d++) if(d !== block) ports.push(d);
                } else if (currNode.type === 'L') {
                    ports.push(currNode.rot);
                    ports.push((currNode.rot + 1) % 4);
                } else if (currNode.type === 'I') { // 黃色一字
                    // Rot 0/2: 通 Up(0) & Down(2)
                    // Rot 1/3: 通 Right(1) & Left(3)
                    if (currNode.rot % 2 === 0) { ports.push(0, 2); }
                    else { ports.push(1, 3); }
                }

                // 檢查周圍連線
                segments.forEach(seg => {
                    let neighborId = (seg.from === currId) ? seg.to : (seg.from === currId ? null : seg.from);
                    if (!neighborId) return;
                    if (seg.from !== currId && seg.to !== currId) return;

                    // 計算相對方位 (currNode -> neighbor)
                    let neighborNode = nodes.find(n => n.id === neighborId);
                    let dx = 0, dy = 0;
                    if (neighborNode) { dx = neighborNode.x - currNode.x; dy = neighborNode.y - currNode.y; }
                    else if (neighborId === 'SOURCE') { dx = 0; dy = -1; } // Source 在上

                    let dir = -1;
                    if (Math.abs(dy) > Math.abs(dx)) dir = dy < 0 ? 0 : 2; // Up : Down
                    else dir = dx > 0 ? 1 : 3; // Right : Left

                    // 規則：如果我的端口有開，且這條線還沒亮
                    if (ports.includes(dir) && !seg.powered) {
                        seg.powered = true;
                        
                        // 檢查鄰居是否接收 (雙向握手)
                        if (neighborNode) {
                            let nPorts = [];
                            if (neighborNode.type === 'T') {
                                let block = (neighborNode.rot + 2) % 4;
                                for(let d=0; d<4; d++) if(d !== block) nPorts.push(d);
                            } else if (neighborNode.type === 'L') {
                                nPorts.push(neighborNode.rot);
                                nPorts.push((neighborNode.rot + 1) % 4);
                            } else if (neighborNode.type === 'I') {
                                if (neighborNode.rot % 2 === 0) { nPorts.push(0, 2); }
                                else { nPorts.push(1, 3); }
                            }
                            
                            // 反向方位 (Neighbor 看 CurrNode)
                            let incomeDir = (dir + 2) % 4;
                            if (nPorts.includes(incomeDir)) {
                                queue.push(neighborId);
                            }
                        }
                    }
                });
            }

            // 結算目標
            let litCount = 0;
            targets.forEach(t => {
                if (segments[t.segIdx].powered) {
                    t.powered = true;
                    litCount++;
                }
            });

            // 勝利判斷
            if (litCount === targets.length && isPlaying) {
                isPlaying = false;
                clearInterval(timerInterval);
                statusDisp.innerText = "連線成功";
                statusDisp.style.color = "#00ff00";
                setTimeout(nextLevel, 1000); // 1秒後下一關
            } else {
                statusDisp.innerText = isPlaying ? "維修中..." : "斷線";
                statusDisp.style.color = isPlaying ? "#ffcc00" : "#ff3333";
            }
        }

        // --- 5. 繪圖 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 電池
            ctx.fillStyle = "#1a1a1a"; ctx.fillRect(CX - 50, 20, 100, 50);
            ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.setLineDash([]); ctx.strokeRect(CX - 50, 20, 100, 50);
            ctx.fillStyle = "#00ffcc"; ctx.font = "bold 16px Arial"; ctx.fillText("POWER", CX - 30, 52);

            // 線路
            segments.forEach(seg => {
                ctx.beginPath();
                if (seg.powered) {
                    ctx.strokeStyle = "#00ffcc"; ctx.setLineDash([]); ctx.lineWidth = 3;
                    ctx.shadowBlur = 15; ctx.shadowColor = "#00ffcc";
                } else {
                    ctx.strokeStyle = "#333"; ctx.setLineDash([5, 8]); ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                }
                ctx.moveTo(seg.points[0][0], seg.points[0][1]);
                for(let i=1; i<seg.points.length; i++) ctx.lineTo(seg.points[i][0], seg.points[i][1]);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;

            // 目標
            targets.forEach(t => {
                ctx.beginPath();
                if (t.powered) {
                    ctx.fillStyle = "#00ff00"; ctx.strokeStyle = "#00ffcc"; ctx.shadowBlur = 20; ctx.shadowColor = "#00ff00";
                } else {
                    ctx.fillStyle = "#003311"; ctx.strokeStyle = "#006644"; ctx.shadowBlur = 0;
                }
                ctx.arc(t.x, t.y, 20, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = t.powered ? "#ffffff" : "#005533";
                ctx.beginPath(); ctx.arc(t.x, t.y, 6, 0, Math.PI*2); ctx.fill();
            });
            ctx.shadowBlur = 0;

            // 節點
            nodes.forEach(n => {
                // 紅框
                ctx.strokeStyle = "red"; ctx.lineWidth = 2; ctx.setLineDash([]);
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50);

                // 編號
                ctx.fillStyle = "#ff5555"; ctx.font = "bold 12px Arial";
                ctx.fillText(n.display, n.x + 15, n.y - 15);

                // 符號繪製
                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.rot * Math.PI / 2);
                
                // 顏色：黃色特殊符號用黃色，其他用藍色/白色
                let color = n.powered ? "#ffffff" : "#0055aa";
                if (n.type === 'I') color = n.powered ? "#ffffcc" : "#ddcc00"; // 黃色

                ctx.strokeStyle = color;
                ctx.lineWidth = 4; ctx.lineCap = "round";
                ctx.beginPath();
                
                if (n.type === 'T') {
                    ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.moveTo(0, 0); ctx.lineTo(0, -15);
                } else if (n.type === 'L') {
                    ctx.moveTo(0, -15); ctx.lineTo(0, 0); ctx.lineTo(15, 0);
                } else if (n.type === 'I') { // 畫一條直線
                    ctx.moveTo(0, -18); ctx.lineTo(0, 18); // 直線
                    // 裝飾一下讓它看起來像黃色特殊管線
                    if (!n.powered) {
                        ctx.strokeStyle = "#aa8800";
                        ctx.lineWidth = 6; ctx.stroke();
                        ctx.lineWidth = 2; ctx.strokeStyle = "#ffff00"; 
                    }
                }
                ctx.stroke();
                ctx.restore();
            });
        }

        // --- 6. 互動 ---
        canvas.addEventListener('click', (e) => {
            if (!isPlaying) return;

            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            let clickedLayer = -1;
            for (let n of nodes) {
                if (mx > n.x - 25 && mx < n.x + 25 && my > n.y - 25 && my < n.y + 25) {
                    clickedLayer = n.layer;
                    break;
                }
            }

            if (clickedLayer !== -1) {
                nodes.forEach(n => {
                    if (n.layer === clickedLayer) {
                        n.rot = (n.rot + 1) % 4;
                    }
                });
                calculatePower();
                draw();
            }
        });

    </script>
</body>
</html>
