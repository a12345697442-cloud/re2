<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修專家 - 智能演算版</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        
        #ui-bar { 
            position: absolute; top: 0; left: 0; width: 100%; height: 60px; 
            background: rgba(0, 20, 10, 0.9); border-bottom: 1px solid #00ffcc;
            display: flex; justify-content: center; align-items: center; gap: 30px;
            pointer-events: none; z-index: 10;
        }
        .stat-box { font-size: 20px; color: #00ffcc; text-shadow: 0 0 5px #00ffcc; font-weight: bold; }
        .stat-value { color: #fff; margin-left: 10px; }
        .warning { color: #ff3333; animation: pulse 1s infinite; }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            backdrop-filter: blur(5px);
        }
        h1 { color: #00ffcc; font-size: 48px; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 20px #00ffcc; }
        p { font-size: 18px; color: #aaa; margin-bottom: 30px; max-width: 600px; line-height: 1.6; }
        button {
            padding: 15px 40px; font-size: 24px; color: #000; background: #00ffcc;
            border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 15px #00ffcc; transition: transform 0.2s;
        }
        button:hover { transform: scale(1.1); background: #fff; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        canvas { background: #000; border: 2px solid #333; cursor: pointer; display: block; margin: 60px auto 0; box-shadow: 0 0 30px #001100; }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div class="stat-box">LEVEL <span id="level-disp" class="stat-value">1 / 3</span></div>
        <div class="stat-box">TIME <span id="time-disp" class="stat-value">60</span></div>
        <div class="stat-box">TARGETS <span id="target-disp" class="stat-value">0/3</span></div>
    </div>

    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <div id="overlay">
        <h1 id="overlay-title">電路維修專家</h1>
        <p id="overlay-desc">
            歡迎來到電力中樞。<br>
            <strong>Level 1 目標：點亮 3 個電源。</strong><br>
            <span style="color:#ffff00">系統：AI 運算完畢。開局無連線，保證有解且燒腦。</span>
        </p>
        <button id="overlay-btn" onclick="startGame()">開始挑戰</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelDisp = document.getElementById('level-disp');
        const timeDisp = document.getElementById('time-disp');
        const targetDisp = document.getElementById('target-disp');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayDesc = document.getElementById('overlay-desc');
        const overlayBtn = document.getElementById('overlay-btn');

        const CX = 400; 
        const CY = 480; 
        const BOX_SIZES = [600, 460, 320, 180]; 

        let currentLevel = 1;
        let timeLeft = 60;
        let timerInterval = null;
        let isPlaying = false;
        let isLevelComplete = false;
        let hasPlayerMoved = false; 
        
        let nodes = [];
        let segments = [];
        let targets = [];
        let targetCount = 3; 

        // --- 1. 關卡難度設定 ---
        function getLevelConfig(level) {
            switch(level) {
                // Level 1: 3目標, T型, 至少3步
                case 1: return { types: ['T'], targetCount: 3, minMoves: 3, time: 60 };
                // Level 2: 4目標, T+L型, 至少5步
                case 2: return { types: ['T', 'L'], targetCount: 4, minMoves: 5, time: 90 };
                // Level 3: 6目標, T+L+Y型, 至少10步
                case 3: return { types: ['T', 'L', 'Y'], targetCount: 6, minMoves: 10, time: 120 }; 
                default: return { types: ['T'], targetCount: 3, minMoves: 3, time: 60 };
            }
        }

        // --- 2. 遊戲控制 ---
        function startGame() {
            currentLevel = 1;
            startLevel(currentLevel);
        }

        function startLevel(level) {
            const config = getLevelConfig(level);
            targetCount = config.targetCount;

            overlay.style.display = 'none';
            levelDisp.innerText = `${level} / 3`;
            timeLeft = config.time;
            timeDisp.innerText = timeLeft;
            timeDisp.className = "stat-value";
            targetDisp.innerText = `0 / ${targetCount}`;
            targetDisp.style.color = "#fff";
            
            isPlaying = true;
            isLevelComplete = false;
            hasPlayerMoved = false;

            // 核心：生成並驗證地圖
            generateVerifiedLevel(level, config);
            
            draw();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!isPlaying || isLevelComplete) return;
                timeLeft--;
                timeDisp.innerText = timeLeft;
                if (timeLeft <= 10) timeDisp.className = "stat-value warning";
                if (timeLeft <= 0) gameOver();
            }, 1000);
        }

        function levelCleared() {
            isLevelComplete = true;
            targetDisp.style.color = "#00ff00";
            targetDisp.innerText = "OK";
            
            let msg = `Level ${currentLevel} 完成！<br>剩餘時間: ${timeLeft} 秒`;
            let btn = "前往下一關";
            let action = nextLevel;

            if (currentLevel >= 3) {
                msg = "恭喜！全數關卡已修復完成。<br>你是真正的電路大師。";
                btn = "重新開始";
                action = startGame;
            }
            
            setTimeout(() => {
                showOverlay("系統恢復", msg, btn, action);
            }, 500);
        }

        function nextLevel() {
            currentLevel++;
            startLevel(currentLevel);
        }

        function gameOver() {
            isPlaying = false;
            clearInterval(timerInterval);
            showOverlay("電力中斷", `時間耗盡！Level ${currentLevel} 挑戰失敗。`, "重試本關", () => startLevel(currentLevel));
        }

        function showOverlay(title, desc, btnText, callback) {
            overlayTitle.innerHTML = title;
            overlayDesc.innerHTML = desc;
            overlayBtn.innerText = btnText;
            overlayBtn.onclick = callback;
            overlay.style.display = 'flex';
        }

        // --- 3. 智能地圖生成器 (Generator & Solver) ---
        
        function generateVerifiedLevel(level, config) {
            let success = false;
            let attempts = 0;

            // 無限迴圈直到生成合格地圖 (通常 10 次內會成功)
            while (!success && attempts < 2000) {
                attempts++;
                
                // 3.1 建立結構
                initNodes(level, config.types);
                initSegments();
                initTargets(level, config.targetCount);

                // 3.2 暴力搜尋解答 (The Solver)
                // 回傳: { solved: boolean, solutionState: number, litSegments: number }
                let solution = findSolution(config.targetCount);

                if (solution.solved) {
                    // 3.3 檢查虛線條件 (總線段 - 亮線段 >= 2)
                    let totalSegs = segments.length;
                    if (totalSegs - solution.litSegments >= 2) {
                        
                        // 3.4 嘗試尋找一個 "開局全暗" 且 "難度夠高" 的初始狀態
                        if (scrambleBoard(solution.solutionState, config.minMoves)) {
                            success = true; // 完美！找到所有條件都符合的地圖
                        }
                    }
                }
            }
            
            if (!success) console.error("Map Generation Failed");
            
            // 執行一次計算以確保畫面正確
            calculatePower();
        }

        function initNodes(level, allowedTypes) {
            nodes = [];
            BOX_SIZES.forEach((size, i) => {
                const half = size / 2;
                const layerNum = 4 - i;
                
                // 隨機分配類型
                const pick = () => allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
                
                // 特殊規則：最上面的入口節點 (L0_T) 禁止使用 Y 型
                // 原因：Y 型無論怎麼轉都會接通 Source，違反 "開局無連線" 規則
                let tTop = pick();
                if (i === 0 && tTop === 'Y') tTop = 'L'; // 強制換掉

                nodes.push({ id: `L${i}_T`, layer: i, x: CX, y: CY - half, type: tTop, rot: 0, display: layerNum });
                nodes.push({ id: `L${i}_R`, layer: i, x: CX + half, y: CY, type: pick(), rot: 0, display: layerNum });
                nodes.push({ id: `L${i}_B`, layer: i, x: CX, y: CY + half, type: pick(), rot: 0, display: layerNum });
                nodes.push({ id: `L${i}_L`, layer: i, x: CX - half, y: CY, type: pick(), rot: 0, display: layerNum });
            });

            // Level 3 強制檢查：Y 型數量 >= 2 (非入口處)
            if (level === 3) {
                let yNodes = nodes.filter(n => n.type === 'Y');
                if (yNodes.length < 2) {
                    // 強制塞 2 個 Y (避開 L0_T)
                    let safety = 0;
                    while (nodes.filter(n => n.type === 'Y').length < 2 && safety < 10) {
                        let idx = Math.floor(Math.random() * nodes.length);
                        if (nodes[idx].id !== 'L0_T') nodes[idx].type = 'Y';
                        safety++;
                    }
                }
            }
        }

        function initSegments() {
            segments = [];
            const add = (id1, id2, d1, d2, pts) => segments.push({ from: id1, to: id2, fromDir: d1, toDir: d2, points: pts, powered: false });
            
            // Source -> L0_T (2 -> 0)
            segments.push({ from: 'SOURCE', to: 'L0_T', fromDir: 2, toDir: 0, points: [[CX, 70], [CX, CY - 300]], powered: false });

            // Axes
            for(let i=0; i<3; i++) {
                add(`L${i}_T`, `L${i+1}_T`, 2, 0, [[CX, CY-BOX_SIZES[i]/2], [CX, CY-BOX_SIZES[i+1]/2]]);
                add(`L${i}_B`, `L${i+1}_B`, 0, 2, [[CX, CY+BOX_SIZES[i]/2], [CX, CY+BOX_SIZES[i+1]/2]]); 
                add(`L${i}_L`, `L${i+1}_L`, 1, 3, [[CX-BOX_SIZES[i]/2, CY], [CX-BOX_SIZES[i+1]/2, CY]]);
                add(`L${i}_R`, `L${i+1}_R`, 3, 1, [[CX+BOX_SIZES[i]/2, CY], [CX+BOX_SIZES[i+1]/2, CY]]);
            }
            // Center
            add('L3_T', 'L3_B', 2, 0, [[CX, CY-90], [CX, CY+90]]); 
            add('L3_L', 'L3_R', 1, 3, [[CX-90, CY], [CX+90, CY]]); 

            // Rings
            BOX_SIZES.forEach((size, i) => {
                const h = size/2;
                add(`L${i}_T`, `L${i}_R`, 1, 0, [[CX, CY-h], [CX+h, CY-h], [CX+h, CY]]);
                add(`L${i}_R`, `L${i}_B`, 2, 1, [[CX+h, CY], [CX+h, CY+h], [CX, CY+h]]);
                add(`L${i}_B`, `L${i}_L`, 3, 2, [[CX, CY+h], [CX-h, CY+h], [CX-h, CY]]);
                add(`L${i}_L`, `L${i}_T`, 0, 3, [[CX-h, CY], [CX-h, CY-h], [CX, CY-h]]);
            });
        }

        function initTargets(level, count) {
            targets = [];
            const findSeg = (id1, id2) => segments.findIndex(s => (s.from===id1 && s.to===id2) || (s.from===id2 && s.to===id1));
            const centerV = findSeg('L3_T', 'L3_B');
            const centerH = findSeg('L3_L', 'L3_R');

            let pool = [];
            // 使用固定的高難度目標配置
            if (level === 1) {
                pool = [
                    { x: CX, y: CY, segIndices: [centerV, centerH] },
                    { x: CX + 300, y: CY - 300, segIndices: [findSeg('L0_T', 'L0_R')] },
                    { x: CX - 300, y: CY + 300, segIndices: [findSeg('L0_B', 'L0_L')] }
                ];
            } else if (level === 2) {
                pool = [
                    { x: CX, y: CY, segIndices: [centerV, centerH] },
                    { x: CX - 300, y: CY - 300, segIndices: [findSeg('L0_L', 'L0_T')] },
                    { x: CX + 300, y: CY + 300, segIndices: [findSeg('L0_R', 'L0_B')] },
                    { x: CX + 90, y: CY - 90, segIndices: [findSeg('L3_T', 'L3_R')] }
                ];
            } else {
                pool = [
                    { x: CX, y: CY, segIndices: [centerV, centerH] },
                    { x: CX + 300, y: CY - 300, segIndices: [findSeg('L0_T', 'L0_R')] },
                    { x: CX - 300, y: CY + 300, segIndices: [findSeg('L0_B', 'L0_L')] },
                    { x: CX + 230, y: CY + 230, segIndices: [findSeg('L1_R', 'L1_B')] },
                    { x: CX - 160, y: CY - 160, segIndices: [findSeg('L2_L', 'L2_T')] },
                    { x: CX + 90, y: CY - 90, segIndices: [findSeg('L3_T', 'L3_R')] }
                ];
            }
            for(let i=0; i<count; i++) targets.push({ ...pool[i], powered: false });
        }

        // --- Solver: 遍歷所有狀態 ---
        function findSolution(requiredTargets) {
            // 嘗試所有 256 種層級旋轉組合
            for (let i = 0; i < 256; i++) {
                applyState(i);
                let litT = simPower().targets;
                
                if (litT === requiredTargets) {
                    let litS = segments.filter(s => s.simPowered).length;
                    return { solved: true, solutionState: i, litSegments: litS };
                }
            }
            return { solved: false };
        }

        // --- Scrambler: 尋找符合條件的初始狀態 ---
        function scrambleBoard(solState, minMoves) {
            let bestStart = -1;
            
            // 隨機嘗試 100 種打亂
            for (let k = 0; k < 100; k++) {
                let rndState = Math.floor(Math.random() * 256);
                if (rndState === solState) continue; // 避免直接隨機到答案

                // 計算步數距離 (Difficulty)
                let dist = 0;
                let tempS = solState;
                let tempR = rndState;
                for(let l=0; l<4; l++) {
                    let rS = tempS % 4;
                    let rR = tempR % 4;
                    // 計算順時針轉幾次能到答案
                    // dist += (rS - rR + 4) % 4; // 這樣算步數
                    // 只要不同就算 1 步? 題目要求"動三次"，指點擊次數
                    dist += (rS - rR + 4) % 4; 
                    
                    tempS = Math.floor(tempS / 4);
                    tempR = Math.floor(tempR / 4);
                }

                if (dist >= minMoves) {
                    // 檢查是否全暗
                    applyState(rndState);
                    
                    // 檢查1: 亮起的線段數 (最好是0, 或是極少)
                    // 檢查2: L0_T 是否連接 Source (Port 0)
                    // 最嚴格檢查: L0_T 必須斷開 Source
                    let l0_t = nodes.find(n => n.id === 'L0_T');
                    let isSourceBlocked = true;
                    // Source connects to Port 0.
                    // T: connects 0 unless rot=2 (Down)
                    // L: connects 0 if rot=0,3
                    // Y: Always connects 0 (Rot 0,1,2,3 all have 0) -> 這就是為什麼 L3 之前有問題
                    // 所以前面我們禁用了 L0_T 為 Y
                    
                    let connectsSource = false;
                    let ports = getExitPorts(l0_t.type, l0_t.rot, -1); // -1 dummy
                    // getExitPorts logic:
                    if (l0_t.type === 'T') {
                        if ((l0_t.rot + 2) % 4 !== 0) connectsSource = true;
                    } else if (l0_t.type === 'L') {
                        if (l0_t.rot === 0 || l0_t.rot === 3) connectsSource = true;
                    } else if (l0_t.type === 'Y') {
                        connectsSource = true; 
                    }

                    if (!connectsSource) {
                        // 這是完美的開局：Source 直接斷掉，全場全暗
                        return true; 
                    }
                }
            }
            return false;
        }

        function applyState(state) {
            let temp = state;
            for (let layer = 0; layer < 4; layer++) {
                let rot = temp % 4;
                temp = Math.floor(temp / 4);
                nodes.filter(n => n.layer === layer).forEach(n => n.rot = rot);
            }
        }

        // --- 核心邏輯 ---
        function getExitPorts(type, rot, entry) {
            let exits = [];
            if (type === 'T') {
                let block = (rot + 2) % 4;
                if (entry === -1 || entry !== block) { // -1 means "query all ports"
                    for(let d=0; d<4; d++) if(d !== block && d !== entry) exits.push(d);
                }
            } else if (type === 'L') {
                let p1 = rot, p2 = (rot + 1) % 4;
                if (entry === -1) { exits.push(p1, p2); }
                else if (entry === p1) exits.push(p2);
                else if (entry === p2) exits.push(p1);
            } else if (type === 'Y') {
                let pairs = (rot % 2 === 0) ? [[0, 3], [1, 2]] : [[0, 1], [2, 3]];
                pairs.forEach(pair => {
                    if (entry === -1) { exits.push(pair[0], pair[1]); }
                    else if (entry === pair[0]) exits.push(pair[1]);
                    else if (entry === pair[1]) exits.push(pair[0]);
                });
            }
            return exits;
        }

        function simPower() {
            nodes.forEach(n => n.simPowered = false);
            segments.forEach(s => s.simPowered = false);
            
            let queue = [];
            let startSeg = segments.find(s => s.from === 'SOURCE');
            
            // Check L0_T connection explicitly first
            let l0_t = nodes.find(n => n.id === startSeg.to); // L0_T
            let sourceConnects = false;
            // Source enters L0_T at Port 0
            if (l0_t.type === 'T') sourceConnects = ((l0_t.rot + 2) % 4 !== 0);
            else if (l0_t.type === 'L') sourceConnects = (l0_t.rot === 0 || l0_t.rot === 3);
            else if (l0_t.type === 'Y') sourceConnects = true;

            if (sourceConnects) {
                startSeg.simPowered = true;
                queue.push({ id: l0_t.id, entry: 0 });
            }

            let visited = new Set();
            while(queue.length > 0) {
                let item = queue.shift();
                let currNode = nodes.find(n => n.id === item.id);
                if (!currNode) continue;
                let stateKey = `${item.id}_${item.entry}`;
                if (visited.has(stateKey)) continue;
                visited.add(stateKey);
                currNode.simPowered = true;

                let exitPorts = getExitPorts(currNode.type, currNode.rot, item.entry);
                exitPorts.forEach(exitDir => {
                    let seg = segments.find(s => (s.from === item.id && s.fromDir === exitDir) || (s.to === item.id && s.toDir === exitDir));
                    if (seg) {
                        seg.simPowered = true;
                        let neighborId = (seg.from === item.id) ? seg.to : seg.from;
                        let neighborEntryDir = (seg.from === item.id) ? seg.toDir : seg.fromDir;
                        queue.push({ id: neighborId, entry: neighborEntryDir });
                    }
                });
            }
            let tCount = 0;
            targets.forEach(t => { if (t.segIndices.some(idx => segments[idx].simPowered)) tCount++; });
            return { targets: tCount };
        }

        // --- 實際電力運算 ---
        function calculatePower() {
            nodes.forEach(n => n.powered = false);
            segments.forEach(s => s.powered = false);
            targets.forEach(t => t.powered = false);

            let queue = [];
            let startSeg = segments.find(s => s.from === 'SOURCE');
            
            // Same rigorous check
            let l0_t = nodes.find(n => n.id === startSeg.to);
            let sourceConnects = false;
            if (l0_t.type === 'T') sourceConnects = ((l0_t.rot + 2) % 4 !== 0);
            else if (l0_t.type === 'L') sourceConnects = (l0_t.rot === 0 || l0_t.rot === 3);
            else if (l0_t.type === 'Y') sourceConnects = true;

            if (sourceConnects) {
                startSeg.powered = true;
                queue.push({ id: l0_t.id, entry: 0 });
            }

            let visited = new Set();
            while(queue.length > 0) {
                let item = queue.shift();
                let currNode = nodes.find(n => n.id === item.id);
                if (!currNode) continue;
                let stateKey = `${item.id}_${item.entry}`;
                if (visited.has(stateKey)) continue;
                visited.add(stateKey);
                currNode.powered = true; 

                let exitPorts = getExitPorts(currNode.type, currNode.rot, item.entry);
                exitPorts.forEach(exitDir => {
                    let seg = segments.find(s => (s.from === item.id && s.fromDir === exitDir) || (s.to === item.id && s.toDir === exitDir));
                    if (seg) {
                        seg.powered = true;
                        let neighborId = (seg.from === item.id) ? seg.to : seg.from;
                        let neighborEntryDir = (seg.from === item.id) ? seg.toDir : seg.fromDir;
                        queue.push({ id: neighborId, entry: neighborEntryDir });
                    }
                });
            }

            let litCount = 0;
            targets.forEach(t => {
                let isLit = t.segIndices.some(idx => segments[idx].powered);
                if (isLit) {
                    t.powered = true;
                    litCount++;
                }
            });
            
            targetDisp.innerText = `${litCount} / ${targetCount}`;

            if (hasPlayerMoved && litCount === targetCount && isPlaying && !isLevelComplete) {
                levelCleared();
            }
        }

        // --- 5. 繪圖 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 電池
            ctx.fillStyle = "#1a1a1a"; ctx.fillRect(CX - 50, 20, 100, 50);
            ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.setLineDash([]); ctx.strokeRect(CX - 50, 20, 100, 50);
            ctx.fillStyle = "#00ffcc"; ctx.font = "bold 16px Arial"; ctx.fillText("POWER", CX - 30, 52);

            // 線路
            segments.forEach(seg => {
                ctx.beginPath();
                if (seg.powered) {
                    ctx.strokeStyle = "#00ffcc"; ctx.setLineDash([]); ctx.lineWidth = 3;
                    ctx.shadowBlur = 15; ctx.shadowColor = "#00ffcc";
                } else {
                    ctx.strokeStyle = "#333"; ctx.setLineDash([5, 8]); ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                }
                ctx.moveTo(seg.points[0][0], seg.points[0][1]);
                for(let i=1; i<seg.points.length; i++) ctx.lineTo(seg.points[i][0], seg.points[i][1]);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;

            // 目標
            targets.forEach(t => {
                ctx.beginPath();
                if (t.powered) {
                    ctx.fillStyle = "#00ff00"; ctx.strokeStyle = "#00ffcc"; ctx.shadowBlur = 20; ctx.shadowColor = "#00ff00";
                } else {
                    ctx.fillStyle = "#003311"; ctx.strokeStyle = "#006644"; ctx.shadowBlur = 0;
                }
                ctx.arc(t.x, t.y, 20, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = t.powered ? "#ffffff" : "#005533";
                ctx.beginPath(); ctx.arc(t.x, t.y, 6, 0, Math.PI*2); ctx.fill();
            });
            ctx.shadowBlur = 0;

            // 節點
            nodes.forEach(n => {
                ctx.strokeStyle = "red"; ctx.lineWidth = 2; ctx.setLineDash([]);
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50);

                ctx.fillStyle = "#ff5555"; ctx.font = "bold 12px Arial";
                ctx.fillText(n.display, n.x + 15, n.y - 15);

                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.rot * Math.PI / 2);
                
                let color = n.powered ? "#ffffff" : "#0055aa";
                if (n.type === 'Y') color = n.powered ? "#ffffcc" : "#eebb00";

                ctx.strokeStyle = color;
                ctx.lineWidth = 4; ctx.lineCap = "round";
                
                if (n.type === 'T') {
                    ctx.beginPath();
                    ctx.moveTo(-15, 0); ctx.lineTo(15, 0); 
                    ctx.moveTo(0, 0); ctx.lineTo(0, -15);
                    ctx.stroke();
                } else if (n.type === 'L') {
                    ctx.beginPath();
                    ctx.moveTo(0, -15); ctx.lineTo(0, 0); ctx.lineTo(15, 0);
                    ctx.stroke();
                } else if (n.type === 'Y') { 
                    ctx.beginPath();
                    ctx.moveTo(0, -20); ctx.lineTo(0, -5); ctx.lineTo(-5, 0); ctx.lineTo(-20, 0);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 20); ctx.lineTo(0, 5); ctx.lineTo(5, 0); ctx.lineTo(20, 0);
                    ctx.stroke();
                }
                ctx.restore();
            });
        }

        canvas.addEventListener('click', (e) => {
            if (!isPlaying || isLevelComplete) return;

            hasPlayerMoved = true;

            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            let clickedLayer = -1;
            for (let n of nodes) {
                if (mx > n.x - 25 && mx < n.x + 25 && my > n.y - 25 && my < n.y + 25) {
                    clickedLayer = n.layer;
                    break;
                }
            }

            if (clickedLayer !== -1) {
                nodes.forEach(n => {
                    if (n.layer === clickedLayer) n.rot = (n.rot + 1) % 4;
                });
                calculatePower();
                draw();
            }
        });

    </script>
</body>
</html>
