<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路解謎：大型電網</title>
    <style>
        body { background: #121212; color: #eee; text-align: center; font-family: sans-serif; margin: 0; overflow: hidden; }
        canvas { background: #ffffff; cursor: pointer; border: 10px solid #333; margin-top: 10px; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        .ui { position: absolute; top: 20px; left: 20px; text-align: left; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; pointer-events: none; }
        h1 { margin: 0 0 10px 0; font-size: 20px; color: #4facfe; }
    </style>
</head>
<body>

    <div class="ui">
        <h1>電路維修系統</h1>
        <p>• 點擊 <span style="color:red">紅色方框</span> 旋轉元件</p>
        <p>• 讓電流從頂部電池傳導至 <span style="color:green">綠色目標</span></p>
        <p>• 黃色元件為雙向獨立彎道</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 遊戲設定
        const cols = 9;
        const rows = 9;
        let gridSize;
        const nodes = [];

        // 初始化畫布
        function init() {
            canvas.width = window.innerHeight * 0.9;
            canvas.height = window.innerHeight * 0.9;
            gridSize = canvas.width / (cols + 1);
            createLevel();
            draw();
        }

        function createLevel() {
            for (let y = 1; y <= rows; y++) {
                for (let x = 1; x <= cols; x++) {
                    // 隨機分配類型：T型, L型, 或黃色雙彎道
                    let type = Math.random() > 0.8 ? 'D' : (Math.random() > 0.5 ? 'T' : 'L');
                    
                    // 特殊位置設定：中心點為目標綠燈
                    if (x === 5 && y === 5) type = 'LAMP';
                    
                    nodes.push({
                        x: x,
                        y: y,
                        type: type,
                        rot: Math.floor(Math.random() * 4),
                        isYellow: (type === 'D'),
                        powered: false
                    });
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 繪製背景參考線 (全域虛線網格)
            ctx.setLineDash([5, 10]);
            ctx.strokeStyle = "#e0e0e0";
            ctx.lineWidth = 1;
            for(let i=1; i<=cols; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, gridSize);
                ctx.lineTo(i * gridSize, rows * gridSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gridSize, i * gridSize);
                ctx.lineTo(cols * gridSize, i * gridSize);
                ctx.stroke();
            }

            // 2. 繪製電池 (頂部)
            ctx.setLineDash([]);
            ctx.fillStyle = "#222";
            ctx.fillRect(5 * gridSize - 30, 0, 60, 40);
            ctx.fillStyle = "#4facfe";
            ctx.fillText("BATTERY", 5 * gridSize - 25, 25);

            // 3. 繪製元件
            nodes.forEach(n => {
                const px = n.x * gridSize;
                const py = n.y * gridSize;

                // 紅色外框
                ctx.strokeStyle = "red";
                ctx.lineWidth = 1.5;
                ctx.strokeRect(px - gridSize/2.5, py - gridSize/2.5, gridSize/1.25, gridSize/1.25);

                // 旋轉繪製元件
                ctx.save();
                ctx.translate(px, py);
                if(n.type !== 'LAMP') ctx.rotate(n.rot * Math.PI / 2);
                
                drawComponent(n);
                ctx.restore();
            });
        }

        function drawComponent(n) {
            ctx.lineWidth = 5;
            ctx.lineCap = "round";
            const size = gridSize / 2;
            
            // 顏色設定
            if (n.type === 'LAMP') {
                ctx.fillStyle = n.powered ? "#2ecc71" : "#bdc3c7";
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
                return;
            }

            ctx.strokeStyle = n.isYellow ? "#f1c40f" : "#005596";
            
            if (n.type === 'T') {
                ctx.beginPath();
                ctx.moveTo(-size, 0); ctx.lineTo(size, 0);
                ctx.moveTo(0, 0); ctx.lineTo(0, size);
                ctx.stroke();
            } else if (n.type === 'L') {
                ctx.beginPath();
                ctx.moveTo(0, -size); ctx.lineTo(0, 0); ctx.lineTo(size, 0);
                ctx.stroke();
            } else if (n.type === 'D') {
                // 黃色雙彎道
                ctx.beginPath();
                ctx.arc(-size, -size, size, 0, Math.PI / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(size, size, size, Math.PI, Math.PI * 1.5);
                ctx.stroke();
            }
        }

        // 點擊互動
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            nodes.forEach(n => {
                const px = n.x * gridSize;
                const py = n.y * gridSize;
                const dist = Math.sqrt((mx-px)**2 + (my-py)**2);
                
                if (dist < gridSize/2) {
                    if(n.type !== 'LAMP') {
                        n.rot = (n.rot + 1) % 4;
                        updateLogic(); // 這裡未來可以加入連點判斷
                        draw();
                    }
                }
            });
        });

        function updateLogic() {
            // 目前先做簡單的視覺更新，進階版可加入 DFS 連通演算法
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
