<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RE4 CIRCUIT FINAL</title>
    <style>
        :root {
            --re-green: #3cf08d;
            --re-dim: #102a1a;
            --bg-black: #050806;
        }

        body {
            background-color: var(--bg-black); color: var(--re-green);
            font-family: 'Courier New', monospace;
            display: flex; flex-direction: column; align-items: center;
            margin: 0; height: 100vh; overflow: hidden;
            background-image: radial-gradient(circle, #0d1a12 0%, #000 100%);
        }

        #terminal-container {
            position: relative; width: 360px; height: 400px;
            margin-top: 30px; border: 3px solid #222;
            background: #000; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* 繪圖層 */
        canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }

        /* 工業風大按鈕 */
        .knob {
            position: absolute; width: 50px; height: 50px;
            background: #111; border: 2px solid #333;
            border-radius: 4px; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 0 #000; transition: transform 0.2s, background 0.3s;
            cursor: pointer; -webkit-tap-highlight-color: transparent;
        }
        .knob:active { transform: scale(0.9) !important; background: #222; }
        
        /* 符號視覺 */
        .knob svg { width: 35px; height: 35px; fill: none; stroke: #444; stroke-width: 4; transition: 0.3s; }
        .knob.powered svg { stroke: var(--re-green); filter: drop-shadow(0 0 8px var(--re-green)); }
        .knob.powered { border-color: var(--re-green); box-shadow: 0 0 15px rgba(60, 240, 141, 0.3); }

        /* 固定電源點 */
        .fixed-node {
            position: absolute; width: 24px; height: 24px;
            background: #0a0a0a; border: 2px solid #222;
            border-radius: 4px; z-index: 50; display: flex; 
            justify-content: center; align-items: center;
        }
        .fixed-node.active {
            background: var(--re-green); border-color: #fff;
            box-shadow: 0 0 20px var(--re-green);
        }

        .ui-label { position: absolute; padding: 5px 10px; font-weight: bold; font-size: 14px; z-index: 10; }
        #power-in { top: 10px; left: 10px; border: 1px solid var(--re-green); }
        #goal-stat { top: 10px; right: 10px; color: #fff; }
    </style>
</head>
<body>

    <div id="terminal-container">
        <div class="ui-label" id="power-in">POWER >></div>
        <div class="ui-label" id="goal-stat">CONNECTED: 0 / 3</div>
        <canvas id="mainCanvas" width="360" height="400"></canvas>
    </div>

    <div style="margin-top:30px; text-align:center;">
        <div style="font-size:14px; letter-spacing:2px;">TERMINAL CALIBRATION</div>
        <div style="font-size:10px; color:#444; margin-top:5px;">ROTATE CONNECTORS TO LINK ALL POWER CELLS</div>
    </div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('terminal-container');

    const rings = [140, 95, 50]; // 三層方形軌道半徑
    const knobs = [];
    const cells = [];

    // 初始化數據
    function init() {
        // 1. 生成軌道上的按鈕 (避開轉角)
        // 每層放兩個按鈕，分別在水平和垂直中點
        rings.forEach((r, i) => {
            const positions = [
                {x: 180, y: 200-r, type: 'T'}, // 上軌道中點
                {x: 180+r, y: 200, type: 'L'}  // 右軌道中點
            ];
            positions.forEach(pos => {
                const knob = {
                    x: pos.x, y: pos.y, type: pos.type,
                    rot: Math.floor(Math.random()*4)*90,
                    powered: false, layer: i
                };
                createKnob(knob);
                knobs.push(knob);
            });

            // 2. 生成固定的電源點 (放在每層的轉角處或特定位置)
            const cell = {
                x: 180-r, y: 200+r, active: false, layer: i
            };
            createCell(cell);
            cells.push(cell);
        });

        requestAnimationFrame(render);
        updateLogic();
    }

    function createKnob(k) {
        const el = document.createElement('div');
        el.className = 'knob';
        el.style.left = (k.x - 25) + 'px';
        el.style.top = (k.y - 25) + 'px';
        el.style.transform = `rotate(${k.rot}deg)`;
        el.innerHTML = `<svg viewBox="0 0 40 40">${k.type === 'T' ? '<path d="M0 20 H40 M20 20 V0" />' : '<path d="M20 0 V20 H40" />'}</svg>`;
        
        el.onclick = () => {
            k.rot = (k.rot + 90) % 360;
            el.style.transform = `rotate(${k.rot}deg)`;
            if(window.navigator.vibrate) window.navigator.vibrate(30);
            updateLogic();
        };
        k.el = el;
        container.appendChild(el);
    }

    function createCell(c) {
        const el = document.createElement('div');
        el.className = 'fixed-node';
        el.style.left = (c.x - 12) + 'px';
        el.style.top = (c.y - 12) + 'px';
        c.el = el;
        container.appendChild(el);
    }

    function updateLogic() {
        // 模擬電力傳導邏輯
        // 電力從最外層開始，如果按鈕轉向正確，則點亮該層
        let layerPowered = [true, false, false]; 
        
        knobs.forEach(k => {
            // 簡化邏輯：如果 T 型向上或向下(視角度)，則傳導到下一層
            if(k.layer === 0 && k.rot % 180 === 0) layerPowered[1] = true;
            if(k.layer === 1 && k.rot % 180 === 0) layerPowered[2] = true;
            k.powered = layerPowered[k.layer];
            k.el.classList.toggle('powered', k.powered);
        });

        let activeCount = 0;
        cells.forEach(c => {
            c.active = layerPowered[c.layer];
            c.el.classList.toggle('active', c.active);
            if(c.active) activeCount++;
        });

        document.getElementById('goal-stat').innerText = `CONNECTED: ${activeCount} / 3`;
    }

    function render() {
        ctx.clearRect(0, 0, 360, 400);

        // 繪製背景虛線軌道
        rings.forEach((r, i) => {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = varColor('--re-dim');
            ctx.lineWidth = 2;
            ctx.strokeRect(180-r, 200-r, r*2, r*2);

            // 如果該層通電，繪製發光實線
            const isPowered = knobs.some(k => k.layer === i && k.powered);
            if(isPowered) {
                ctx.setLineDash([]);
                ctx.strokeStyle = varColor('--re-green');
                ctx.lineWidth = 4;
                ctx.shadowBlur = 15;
                ctx.shadowColor = varColor('--re-green');
                ctx.strokeRect(180-r, 200-r, r*2, r*2);
                ctx.shadowBlur = 0;
            }
        });

        // 畫出電力來源線
        ctx.setLineDash([]);
        ctx.strokeStyle = varColor('--re-green');
        ctx.beginPath();
        ctx.moveTo(85, 25); ctx.lineTo(180-rings[0], 25);
        ctx.lineTo(180-rings[0], 200-rings[0]);
        ctx.stroke();

        requestAnimationFrame(render);
    }

    function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    init();
</script>
</body>
</html>
