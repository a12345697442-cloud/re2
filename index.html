<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE2 CIRCUIT - MASTERMIND MODE</title>
    <style>
        @font-face {
            font-family: 'RE_Font';
            src: url('resident_evil_4_remake_font_by_snakeyboy_df7kacs.ttf');
        }

        :root { 
            --pwr-color: #f1c40f; 
            --bg-color: #050505;
            --re-red: #8b0000;
            --locked-bg: #2b0000;
        }

        body { 
            background-color: var(--bg-color); color: #ccc; 
            font-family: 'RE_Font', 'Courier New', sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            margin: 0; height: 100vh; justify-content: center;
            background-image: radial-gradient(circle, #1a1a1a 0%, #000 100%);
        }

        h2 { color: var(--re-red); text-transform: uppercase; letter-spacing: 5px; margin-bottom: 10px; font-size: 2em; }

        #info-panel { 
            margin-bottom: 15px; font-size: 1.2em; display: flex; gap: 40px; 
            background: rgba(20, 20, 20, 0.9); padding: 10px 30px; border: 1px solid #444;
        }

        .timer { color: #f00; font-weight: bold; }
        #game-container { position: relative; padding: 60px; background: #111; border: 4px solid #333; box-shadow: 0 0 100px #000; }
        #game-board { display: grid; gap: 4px; background: #000; padding: 4px; border: 2px solid #222; }

        .port { position: absolute; font-size: 11px; font-weight: bold; text-transform: uppercase; z-index: 5; }
        .in-p { color: var(--pwr-color); left: 10px; }
        .out-p { right: 10px; color: #444; }
        .out-p.active { color: var(--pwr-color); text-shadow: 0 0 15px var(--pwr-color); }
        
        .p-1 { top: 85px; }
        .p-2 { bottom: 85px; }

        .tile { width: 75px; height: 75px; background: #151515; cursor: pointer; position: relative; transition: transform 0.2s; box-sizing: border-box; }
        .tile:hover:not(.locked) { background: #222; }
        .tile.locked { cursor: not-allowed; background: var(--locked-bg); border: 1px solid #600; }
        .tile.locked::before { content: 'FIXED'; position: absolute; font-size: 8px; color: #f00; top: 2px; left: 2px; z-index: 10; opacity: 0.8; }

        .wire { position: absolute; background: #333; z-index: 1; transition: background 0.2s; }
        .tile::after { content: ''; position: absolute; width: 14px; height: 14px; background: #333; left: 30.5px; top: 30.5px; border-radius: 2px; z-index: 2; }

        .w-up { width: 8px; height: 38px; left: 33.5px; top: 0; }
        .w-right { width: 38px; height: 8px; left: 37.5px; top: 33.5px; }
        .w-down { width: 8px; height: 38px; left: 33.5px; top: 37.5px; }
        .w-left { width: 38px; height: 8px; left: 0; top: 33.5px; }

        .powered .wire, .powered::after { background: var(--pwr-color) !important; box-shadow: 0 0 15px var(--pwr-color); }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.98); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        #status-text { font-size: 4em; margin-bottom: 20px; font-family: 'RE_Font', serif; letter-spacing: 2px; }
        .stranger-text { 
            color: #f1c40f; font-size: 2.5em !important; 
            line-height: 2.2; letter-spacing: 12px !important; 
            text-shadow: 0 0 30px rgba(241, 196, 15, 0.8); 
            white-space: pre-line;
        }
        .dead-text { color: #f00; text-shadow: 0 0 20px #f00; }
        .alive-text { color: #0f0; text-shadow: 0 0 20px #0f0; }

        button { background: transparent; color: #fff; border: 1px solid #666; padding: 15px 50px; cursor: pointer; font-size: 1.5em; font-family: 'RE_Font', sans-serif; }
        button:hover { background: #800; border-color: #f00; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <h2>CIRCUIT MASTERMIND</h2>
    
    <div id="info-panel">
        <div>LVL: <span id="lvl-display">1</span></div>
        <div class="timer">TIME: <span id="time-display">60</span></div>
    </div>

    <div id="game-container">
        <div class="port in-p p-1">INPUT A</div>
        <div id="in2-label" class="port in-p p-2 hidden">INPUT B</div>
        
        <div id="game-board"></div>
        
        <div id="out1-label" class="port out-p p-1">OUTPUT A</div>
        <div id="out2-label" class="port out-p p-2 hidden">OUTPUT B</div>
    </div>

    <div id="overlay" class="overlay">
        <h1 id="status-text"></h1>
        <button id="action-btn" onclick="handleBtnClick()">RETRY</button>
    </div>

<script>
    const levels = [
        {size: 3, dual: false, locks: 0},
        {size: 4, dual: true, locks: 3},
        {size: 5, dual: true, locks: 7}
    ];
    let currentLvl = 0, timeLeft = 60, timerId = null, tiles = [], isLocked = false;

    function startGame() {
        isLocked = false;
        document.getElementById('overlay').style.display = 'none';
        const cfg = levels[currentLvl];
        document.getElementById('lvl-display').innerText = currentLvl + 1;
        document.getElementById('in2-label').classList.toggle('hidden', !cfg.dual);
        document.getElementById('out2-label').classList.toggle('hidden', !cfg.dual);
        generateMastermindLevel(cfg);
        startTimer();
    }

    function generateMastermindLevel(cfg) {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        boardEl.style.gridTemplateColumns = `repeat(${cfg.size}, 75px)`;
        tiles = [];

        const gridData = Array.from({length: cfg.size}, () => Array.from({length: cfg.size}, () => ({exits:[]})));
        
        // 1. 強制讓兩條線在中央「碰撞」並共享 T 型塊或交叉
        let pathA = createPathNodes(0, 0, 0, cfg.size-1, cfg.size, true);
        let pathB = cfg.dual ? createPathNodes(cfg.size-1, 0, cfg.size-1, cfg.size-1, cfg.size, false) : [];

        // 轉化為出口數據
        applyPathToGrid(gridData, pathA, 3, 1);
        if(cfg.dual) applyPathToGrid(gridData, pathB, 3, 1);

        for(let r=0; r<cfg.size; r++){
            for(let c=0; c<cfg.size; c++){
                let data = gridData[r][c];
                
                // 核心提升：善用 T 型 (三向) 方塊
                if(data.exits.length === 0) {
                    // 隨機填充 T 型或 L 型作為干擾
                    const types = [[0,1,2], [1,2,3], [2,3,0], [3,0,1], [0,1], [1,2], [2,3], [3,0]];
                    data.exits = types[Math.floor(Math.random()*types.length)];
                } else if(data.exits.length === 2 && Math.random() > 0.5) {
                    // 如果原本是路徑上的 L 型，有機率多加一向變成 T 型增加混淆
                    let extra = [0,1,2,3].find(d => !data.exits.includes(d));
                    data.exits.push(extra);
                }

                const tileWrap = document.createElement('div');
                tileWrap.className = 'tile';
                
                // 提高固定塊比例，並放在關鍵位置
                let isFixed = (cfg.locks > 0 && Math.random() > 0.5 && (r+c > 0));
                if(isFixed) { tileWrap.classList.add('locked'); cfg.locks--; }

                let rot = isFixed ? 0 : Math.floor(Math.random()*4);
                const tileObj = {
                    element: tileWrap, baseExits: [...new Set(data.exits)],
                    currentRotation: rot, isLocked: isFixed,
                    getActualExits: function() { return this.baseExits.map(ex => (ex + this.currentRotation) % 4); }
                };

                tileObj.baseExits.forEach(d => {
                    const w = document.createElement('div');
                    w.className = 'wire ' + ['w-up', 'w-right', 'w-down', 'w-left'][d];
                    tileWrap.appendChild(w);
                });

                tileWrap.style.transform = `rotate(${rot * 90}deg)`;
                tileWrap.onclick = () => { 
                    if(!isLocked && !tileObj.isLocked) { 
                        tileObj.currentRotation = (tileObj.currentRotation + 1) % 4; 
                        tileWrap.style.transform = `rotate(${tileObj.currentRotation * 90}deg)`; 
                        checkCircuit(); 
                    } 
                };
                boardEl.appendChild(tileWrap);
                tiles.push(tileObj);
            }
        }
        checkCircuit();
    }

    function createPathNodes(sr, sc, er, ec, size, wrapDown) {
        let nodes = [{r: sr, c: sc}];
        let mid = Math.floor(size/2);
        let targetR = wrapDown ? mid : mid - 1;
        
        // 增加繞路深度
        for(let c=1; c < size-1; c++) nodes.push({r: targetR, c: c});
        nodes.push({r: targetR, c: size-1});
        nodes.push({r: er, c: ec});
        return nodes;
    }

    function applyPathToGrid(grid, nodes, startIn, endOut) {
        grid[nodes[0].r][nodes[0].c].exits.push(startIn);
        for(let i=0; i<nodes.length-1; i++) {
            let curr = nodes[i], next = nodes[i+1];
            let r = curr.r, c = curr.c;
            while(r !== next.r || c !== next.c) {
                let lr = r, lc = c;
                if(r < next.r) r++; else if(r > next.r) r--; else if(c < next.c) c++;
                let dirOut = (r > lr) ? 2 : (r < lr) ? 0 : (c > lc) ? 1 : 3;
                let dirIn = (dirOut + 2) % 4;
                grid[lr][lc].exits.push(dirOut);
                grid[r][c].exits.push(dirIn);
            }
        }
        grid[nodes[nodes.length-1].r][nodes[nodes.length-1].c].exits.push(endOut);
    }

    function checkCircuit() {
        const cfg = levels[currentLvl], size = cfg.size;
        const p1 = trace(0, 3, size), p2 = cfg.dual ? trace((size-1)*size, 3, size) : new Set();
        tiles.forEach((t, i) => { if(p1.has(i) || (cfg.dual && p2.has(i))) t.element.classList.add('powered'); else t.element.classList.remove('powered'); });
        const win1 = p1.has(size-1) && tiles[size-1].getActualExits().includes(1);
        const win2 = !cfg.dual || (p2.has(size*size-1) && tiles[size*size-1].getActualExits().includes(1));
        document.getElementById('out1-label').classList.toggle('active', win1);
        if(cfg.dual) document.getElementById('out2-label').classList.toggle('active', win2);
        if(win1 && win2) {
            isLocked = true; clearInterval(timerId);
            setTimeout(() => {
                if(currentLvl < levels.length - 1) showOverlay("ALIVE", "NEXT LEVEL");
                else showOverlay("Congratulations, stranger!\nPlease claim your reward.", "");
            }, 600);
        }
    }

    function trace(startIdx, startEntryDir, size) {
        const powered = new Set(), queue = [];
        if(tiles[startIdx].getActualExits().includes(startEntryDir)) queue.push(startIdx);
        while(queue.length > 0) {
            const idx = queue.shift();
            if(powered.has(idx)) continue;
            powered.add(idx);
            const r = Math.floor(idx/size), c = idx%size, exits = tiles[idx].getActualExits();
            const nbs = [{d:0,nr:r-1,nc:c,o:2},{d:1,nr:r,nc:c+1,o:3},{d:2,nr:r+1,nc:c,o:0},{d:3,nr:r,nc:c-1,o:1}];
            nbs.forEach(n => { if(exits.includes(n.d) && n.nr>=0 && n.nr<size && n.nc>=0 && n.nc<size) {
                const nIdx = n.nr*size + n.nc; if(tiles[nIdx].getActualExits().includes(n.o)) queue.push(nIdx);
            }});
        }
        return powered;
    }

    function startTimer() {
        clearInterval(timerId);
        timerId = setInterval(() => { if(!isLocked) { timeLeft--; document.getElementById('time-display').innerText = timeLeft; if(timeLeft <= 0) endGame(); } }, 1000);
    }

    function endGame() { isLocked = true; clearInterval(timerId); showOverlay("YOU ARE DEAD", "RETRY"); }

    function showOverlay(msg, btnTxt) {
        const o = document.getElementById('overlay'), t = document.getElementById('status-text'), b = document.getElementById('action-btn');
        t.innerText = msg; b.innerText = btnTxt;
        if(msg.includes("Congratulations")) { t.className = "stranger-text"; b.classList.add("hidden"); }
        else { t.className = (msg === "ALIVE") ? "alive-text" : "dead-text"; b.classList.remove("hidden"); }
        o.style.display = 'flex';
    }

    function handleBtnClick() { currentLvl = (document.getElementById('action-btn').innerText === "NEXT LEVEL") ? currentLvl+1 : 0; startGame(); }

    startGame();
</script>
</body>
</html>
