<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE2 CIRCUIT - CONTACT FAILURE</title>
    <style>
        @font-face {
            font-family: 'RE_Font';
            src: url('resident_evil_4_remake_font_by_snakeyboy_df7kacs.ttf');
        }

        :root { 
            --pwr-color: #f1c40f; 
            --bg-color: #050505;
            --re-red: #8b0000;
            --locked-bg: #2b0000;
        }

        body { 
            background-color: var(--bg-color); color: #ccc; 
            font-family: 'RE_Font', 'Courier New', sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            margin: 0; height: 100vh; justify-content: center;
            background-image: radial-gradient(circle, #1a1a1a 0%, #000 100%);
            overflow: hidden;
        }

        h2 { color: var(--re-red); text-transform: uppercase; letter-spacing: 5px; margin-bottom: 10px; font-size: 2em; }

        #info-panel { 
            margin-bottom: 15px; font-size: 1.2em; display: flex; gap: 40px; 
            background: rgba(20, 20, 20, 0.9); padding: 10px 30px; border: 1px solid #444;
        }

        .timer { color: #f00; font-weight: bold; }
        #game-container { position: relative; padding: 60px; background: #111; border: 4px solid #333; box-shadow: 0 0 100px #000; }
        #game-board { display: grid; gap: 4px; background: #000; padding: 4px; border: 2px solid #222; }

        .port { position: absolute; font-size: 11px; font-weight: bold; text-transform: uppercase; z-index: 5; }
        .in-p { color: var(--pwr-color); left: 10px; top: 85px; text-shadow: 0 0 5px var(--pwr-color); }
        .out-p { right: 10px; bottom: 85px; color: #444; }
        .out-p.active { color: var(--pwr-color); text-shadow: 0 0 15px var(--pwr-color); }

        .tile { width: 75px; height: 75px; background: #151515; cursor: pointer; position: relative; transition: transform 0.2s; }
        .tile.locked { cursor: not-allowed; background: var(--locked-bg); border: 1px solid #600; }
        .tile.locked::before { content: 'FIXED'; position: absolute; font-size: 8px; color: #f00; top: 2px; left: 2px; z-index: 10; }

        .wire { position: absolute; background: #333; z-index: 1; transition: background 0.2s; }
        .tile::after { content: ''; position: absolute; width: 14px; height: 14px; background: #333; left: 30.5px; top: 30.5px; border-radius: 2px; z-index: 2; }
        
        /* 導向位置 */
        .w-up { width: 8px; height: 38px; left: 33.5px; top: 0; }
        .w-right { width: 38px; height: 8px; left: 37.5px; top: 33.5px; }
        .w-down { width: 8px; height: 38px; left: 33.5px; top: 37.5px; }
        .w-left { width: 38px; height: 8px; left: 0; top: 33.5px; }

        /* 通電效果 */
        .powered .wire:not(.fake), .powered::after { background: var(--pwr-color) !important; box-shadow: 0 0 15px var(--pwr-color); }
        
        /* 接觸不良閃爍效果 (假線) */
        .flicker .wire.fake { animation: contact-failure 0.5s infinite; }
        @keyframes contact-failure {
            0%, 20%, 40% { background: var(--pwr-color); box-shadow: 0 0 10px var(--pwr-color); }
            10%, 30%, 50% { background: #333; box-shadow: none; }
            100% { background: #333; }
        }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.98); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        #status-text { font-size: 4em; margin-bottom: 20px; font-family: 'RE_Font', serif; letter-spacing: 2px; }
        .stranger-text { 
            color: #f1c40f; font-size: 2.5em !important; 
            line-height: 2.5; letter-spacing: 15px !important; 
            text-shadow: 0 0 30px rgba(241, 196, 15, 0.8); 
            white-space: pre-line;
        }

        button { background: transparent; color: #fff; border: 1px solid #666; padding: 15px 50px; cursor: pointer; font-size: 1.5em; font-family: 'RE_Font', sans-serif; }
        button:hover { background: #800; border-color: #f00; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <h2>POWER GRID: CONTACT FAILURE</h2>
    
    <div id="info-panel">
        <div>LVL: <span id="lvl-display">1</span></div>
        <div class="timer">SEC: <span id="time-display">60</span></div>
    </div>

    <div id="game-container">
        <div class="port in-p">INPUT</div>
        <div id="game-board"></div>
        <div id="out-label" class="port out-p">OUTPUT</div>
    </div>

    <div id="overlay" class="overlay">
        <h1 id="status-text"></h1>
        <button id="action-btn" onclick="handleBtnClick()">RETRY</button>
    </div>

<script>
    const levels = [
        {size: 3, locks: 0, fakeChance: 0},
        {size: 4, locks: 3, fakeChance: 0.5},
        {size: 5, locks: 7, fakeChance: 0.7}
    ];
    let currentLvl = 0, timeLeft = 60, timerId = null, tiles = [], isLocked = false;

    function startGame() {
        isLocked = false;
        document.getElementById('overlay').style.display = 'none';
        const cfg = levels[currentLvl];
        document.getElementById('lvl-display').innerText = currentLvl + 1;
        generateLevel(cfg);
        startTimer();
    }

    function generateLevel(cfg) {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        boardEl.style.gridTemplateColumns = `repeat(${cfg.size}, 75px)`;
        tiles = [];

        // 建立資料網格
        const grid = Array.from({length: cfg.size}, () => Array.from({length: cfg.size}, () => ({real:[], fake:[]})));
        
        // 生成蜿蜒路徑
        let r = 0, c = 0;
        grid[r][c].real.push(3); 
        while(r < cfg.size-1 || c < cfg.size-1) {
            let lr = r, lc = c;
            if(r < cfg.size-1 && (Math.random() > 0.5 || c === cfg.size-1)) r++; else c++;
            let out = (r > lr) ? 2 : 1;
            let inv = (out === 2) ? 0 : 3;
            grid[lr][lc].real.push(out);
            grid[r][c].real.push(inv);
        }
        grid[cfg.size-1][cfg.size-1].real.push(1);

        // 決定固定塊 (分散佈置)
        let lockIdx = new Set();
        let attempts = 0;
        while(lockIdx.size < cfg.locks && attempts < 100) {
            let rand = Math.floor(Math.random() * (cfg.size*cfg.size));
            if(rand !== 0 && rand !== cfg.size*cfg.size-1) {
                let pr = Math.floor(rand/cfg.size), pc = rand%cfg.size;
                let near = false;
                lockIdx.forEach(idx => {
                    if(Math.abs(Math.floor(idx/cfg.size)-pr) + Math.abs((idx%cfg.size)-pc) < 2) near = true;
                });
                if(!near) lockIdx.add(rand);
            }
            attempts++;
        }

        for(let r=0; r<cfg.size; r++) {
            for(let c=0; c<cfg.size; c++) {
                let data = grid[r][c];
                const idx = r*cfg.size + c;

                // 注入偽裝 T 型邏輯
                if(data.real.length > 0 && Math.random() < cfg.fakeChance) {
                    let possible = [0,1,2,3].filter(d => !data.real.includes(d));
                    data.fake.push(possible[Math.floor(Math.random()*possible.length)]);
                } else if(data.real.length === 0) {
                    // 死路塊填充
                    data.fake = [[0,2],[1,3],[0,1,2]][Math.floor(Math.random()*3)];
                }

                const wrap = document.createElement('div');
                wrap.className = 'tile' + (lockIdx.has(idx) ? ' locked' : '');
                let rot = lockIdx.has(idx) ? 0 : Math.floor(Math.random()*4);

                const tileObj = {
                    element: wrap,
                    real: data.real,
                    fake: data.fake,
                    rot: rot,
                    isLocked: lockIdx.has(idx),
                    getPowerExits: function() { return this.real.map(d => (d + this.rot) % 4); },
                    getFakeExits: function() { return this.fake.map(d => (d + this.rot) % 4); }
                };

                // 畫實線
                tileObj.real.forEach(d => {
                    let w = document.createElement('div');
                    w.className = 'wire ' + ['w-up','w-right','w-down','w-left'][d];
                    wrap.appendChild(w);
                });
                // 畫假線 (接觸不良)
                tileObj.fake.forEach(d => {
                    let w = document.createElement('div');
                    w.className = 'wire fake ' + ['w-up','w-right','w-down','w-left'][d];
                    wrap.appendChild(w);
                });

                wrap.style.transform = `rotate(${rot * 90}deg)`;
                wrap.onclick = () => {
                    if(isLocked || tileObj.isLocked) return;
                    tileObj.rot = (tileObj.rot + 1) % 4;
                    wrap.style.transform = `rotate(${tileObj.rot * 90}deg)`;
                    checkCircuit();
                };
                boardEl.appendChild(wrap);
                tiles.push(tileObj);
            }
        }
        checkCircuit();
    }

    function checkCircuit() {
        const size = levels[currentLvl].size;
        tiles.forEach(t => { t.element.classList.remove('powered', 'flicker'); });

        const powered = new Set(), queue = [];
        if(tiles[0].getPowerExits().includes(3)) queue.push(0);

        while(queue.length > 0) {
            const idx = queue.shift();
            if(powered.has(idx)) continue;
            powered.add(idx);
            tiles[idx].element.classList.add('powered');
            
            // 接觸不良視覺提示：如果這格通電，且這格有假線，觸發閃爍
            if(tiles[idx].fake.length > 0) tiles[idx].element.classList.add('flicker');

            const r = Math.floor(idx/size), c = idx%size;
            const exits = tiles[idx].getPowerExits();
            const nbs = [{d:0,nr:r-1,nc:c,o:2},{d:1,nr:r,nc:c+1,o:3},{d:2,nr:r+1,nc:c,o:0},{d:3,nr:r,nc:c-1,o:1}];
            
            nbs.forEach(n => {
                if(exits.includes(n.d) && n.nr>=0 && n.nr<size && n.nc>=0 && n.nc<size) {
                    const nidx = n.nr*size+n.nc;
                    if(tiles[nidx].getPowerExits().includes(n.o)) queue.push(nidx);
                }
            });
        }

        const win = powered.has(tiles.length-1) && tiles[tiles.length-1].getPowerExits().includes(1);
        document.getElementById('out-label').classList.toggle('active', win);
        if(win) {
            isLocked = true; clearInterval(timerId);
            setTimeout(() => {
                if(currentLvl < levels.length - 1) showOverlay("ALIVE", "NEXT LEVEL");
                else showOverlay("Congratulations, stranger!\nPlease claim your reward.", "");
            }, 800);
        }
    }

    function startTimer() {
        clearInterval(timerId);
        timerId = setInterval(() => {
            if(!isLocked) { timeLeft--; document.getElementById('time-display').innerText = timeLeft; if(timeLeft <= 0) endGame(); }
        }, 1000);
    }

    function endGame() { isLocked = true; clearInterval(timerId); showOverlay("YOU ARE DEAD", "RETRY"); }

    function showOverlay(msg, btnTxt) {
        const o = document.getElementById('overlay'), t = document.getElementById('status-text'), b = document.getElementById('action-btn');
        t.innerText = msg; b.innerText = btnTxt;
        if(msg.includes("Congratulations")) { t.className = "stranger-text"; b.classList.add("hidden"); }
        else { t.className = (msg === "ALIVE") ? "alive-text" : "dead-text"; b.classList.remove("hidden"); }
        o.style.display = 'flex';
    }

    function handleBtnClick() { currentLvl = (document.getElementById('action-btn').innerText === "NEXT LEVEL") ? currentLvl+1 : 0; startGame(); }

    startGame();
</script>
</body>
</html>
