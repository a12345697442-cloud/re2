<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路修復終端機</title>
    <style>
        body { background: #050505; color: #00ffcc; text-align: center; font-family: 'Courier New', Courier, monospace; }
        canvas { background: #000; border: 2px solid #00ffcc; cursor: pointer; box-shadow: 0 0 15px #00ffcc; margin-top: 20px; }
        .status { margin: 10px; font-size: 1.2em; text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>

    <div class="status" id="msg">Status: Insufficient Power. Calibration Required.</div>
    <canvas id="gameCanvas" width="800" height="800"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 定義連接方向：0:上, 1:右, 2:下, 3:左
        const T_SHAPE = { type: 'T', connects: [1, 2, 3] }; // 初始向下T
        const L_SHAPE = { type: 'L', connects: [0, 1] };    // 初始L
        const D_SHAPE = { type: 'D', connects: [[0, 3], [1, 2]] }; // 黃色雙彎道(獨立組)

        // 建立地圖節點 (依據 1.jpg 的十字分佈)
        // x, y 為座標, type 為類型, rot 為旋轉次數(0-3)
        let nodes = [
            { x: 4, y: 1, type: 'T', rot: 2, powered: false }, // 頂部入口
            { x: 4, y: 2, type: 'T', rot: 2, powered: false },
            { x: 4, y: 3, type: 'T', rot: 0, powered: false },
            { x: 4, y: 4, type: 'D', rot: 0, powered: false, isYellow: true }, // 黃色特殊件
            { x: 4, y: 5, type: 'CORE', powered: false }, // 中心大綠燈
            { x: 3, y: 4, type: 'T', rot: 3, powered: false },
            { x: 5, y: 4, type: 'L', rot: 1, powered: false },
            // 可在此處依據圖片座標繼續增加其餘 20+ 個紅色方框
        ];

        // 預設固定背景線路 (x1, y1, x2, y2)
        const wires = [
            { x1: 4, y1: 0, x2: 4, y2: 1 }, // 電池到入口
            { x1: 4, y1: 1, x2: 4, y2: 2 },
            { x1: 4, y1: 2, x2: 4, y2: 3 },
            { x1: 4, y1: 3, x2: 4, y2: 4 },
            { x1: 4, y1: 4, x2: 4, y2: 5 },
            { x1: 3, y1: 4, x2: 4, y2: 4 },
            { x1: 4, y1: 4, x2: 5, y2: 4 }
        ];

        const gridSize = 80;
        const offset = 80;

        function updatePower() {
            // 1. 重設所有電力
            nodes.forEach(n => n.powered = false);
            
            // 2. 從電池 (4,0) 開始計算傳導 (簡化邏輯演示)
            // 實際完整版會使用遞迴偵測 rotation 與 connects 是否對齊
            let entry = nodes.find(n => n.x === 4 && n.y === 1);
            if (entry.rot === 0 || entry.rot === 2) { // 假設對齊
                entry.powered = true;
                // 模擬向下傳導...
                nodes[1].powered = true; 
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 畫最上方電池
            ctx.fillStyle = "#111";
            ctx.fillRect(4*gridSize+offset-40, 10, 80, 40);
            ctx.strokeStyle = "#00ffcc";
            ctx.strokeRect(4*gridSize+offset-40, 10, 80, 40);
            ctx.fillStyle = "#00ffcc";
            ctx.fillText("POWER", 4*gridSize+offset-25, 35);

            // 畫線路 (核心邏輯：接通=實線, 未接通=虛線)
            wires.forEach(w => {
                ctx.beginPath();
                // 尋找此線段對應的節點是否通電
                let p1 = nodes.find(n => n.x === w.x1 && n.y === w.y1);
                let p2 = nodes.find(n => n.x === w.x2 && n.y === w.y2);
                
                if ((p1 && p1.powered) || (w.y1 === 0)) { // 如果來源有電
                    ctx.setLineDash([]); 
                    ctx.strokeStyle = "#00ffcc";
                } else {
                    ctx.setLineDash([5, 8]);
                    ctx.strokeStyle = "#222";
                }
                
                ctx.moveTo(w.x1 * gridSize + offset, w.y1 * gridSize + offset);
                ctx.lineTo(w.x2 * gridSize + offset, w.y2 * gridSize + offset);
                ctx.stroke();
            });

            // 畫節點符號
            nodes.forEach(n => {
                const px = n.x * gridSize + offset;
                const py = n.y * gridSize + offset;

                // 紅色操作框
                ctx.setLineDash([]);
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.strokeRect(px - 25, py - 25, 50, 50);

                // 畫內部符號
                ctx.save();
                ctx.translate(px, py);
                if(n.type !== 'CORE') ctx.rotate(n.rot * Math.PI / 2);
                
                ctx.lineWidth = 4;
                ctx.strokeStyle = n.isYellow ? "#ffff00" : "#00ffcc";
                
                if (n.type === 'T') {
                    ctx.beginPath();
                    ctx.moveTo(-25, 0); ctx.lineTo(25, 0);
                    ctx.moveTo(0, 0); ctx.lineTo(0, 25);
                    ctx.stroke();
                } else if (n.type === 'L') {
                    ctx.beginPath();
                    ctx.moveTo(0, -25); ctx.lineTo(0, 0); ctx.lineTo(25, 0);
                    ctx.stroke();
                } else if (n.type === 'D') {
                    // 黃色特殊件 (兩條獨立連通線)
                    ctx.beginPath(); ctx.arc(-25, -25, 25, 0, Math.PI/2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(25, 25, 25, Math.PI, Math.PI*1.5); ctx.stroke();
                } else if (n.type === 'CORE') {
                    ctx.fillStyle = n.powered ? "#00ff00" : "#333";
                    ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            });
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            nodes.forEach(n => {
                const px = n.x * gridSize + offset;
                const py = n.y * gridSize + offset;
                if (mx > px - 25 && mx < px + 25 && my > py - 25 && my < py + 25) {
                    if (n.type !== 'CORE') {
                        n.rot = (n.rot + 1) % 4;
                        updatePower();
                        draw();
                    }
                }
            });
        });

        updatePower();
        draw();
    </script>
</body>
</html>
