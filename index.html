<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修 - 精確對齊與分佈版</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: sans-serif; }
        canvas { background: #000; border: 2px solid #333; margin-top: 10px; }
    </style>
</head>
<body>
    <h3 style="color:#00ffcc">關卡配置修正：紅框居中、電源居角、互不遮擋</h3>
    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 定義標準座標常量
        const CX = 450; // 垂直主軸
        const CY = 425; // 水平主軸
        // 定義三層框的邊界 (x, y, width, height)
        const BOXES = [
            { x: 100, y: 100, w: 650, h: 650 }, // 外層
            { x: 200, y: 200, w: 450, h: 450 }, // 中層
            { x: 300, y: 300, w: 250, h: 250 }  // 內層
        ];

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 左上角電池
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(50, 20, 150, 70);
            ctx.strokeStyle = "#00ffcc";
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 20, 150, 70);

            // 2. 電線佈局 (灰色虛線)
            ctx.strokeStyle = "#444";
            ctx.setLineDash([5, 8]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // 引線：電池至垂直主軸
            ctx.moveTo(200, 55); ctx.lineTo(CX, 55); ctx.lineTo(CX, 100);

            // 繪製三層方框與十字軸
            BOXES.forEach(b => ctx.strokeRect(b.x, b.y, b.w, b.h));
            ctx.moveTo(CX, 55); ctx.lineTo(CX, 750); // 垂直主軸
            ctx.moveTo(100, CY); ctx.lineTo(750, CY); // 水平主軸
            ctx.stroke();

            // 3. 放置紅色方格 (每圈 4 個，位於邊線中點，確保在線的交界處)
            ctx.setLineDash([]);
            const nodes = [];
            BOXES.forEach(b => {
                // 每層框與十字軸的 4 個交匯點
                nodes.push({x: CX, y: b.y});           // 上邊中點
                nodes.push({x: CX, y: b.y + b.h});     // 下邊中點
                nodes.push({x: b.x, y: CY});           // 左邊中點
                nodes.push({x: b.x + b.w, y: CY});     // 右邊中點
            });
            // 補足中心點附近的 4 個關鍵位置
            nodes.push({x: CX, y: 150}, {x: CX, y: 700}, {x: 150, y: CY}, {x: 700, y: CY});

            nodes.forEach(n => {
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                // 繪製方框，圓心精確對準線段
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50);
            });

            // 4. 放置 6 個電源點 (放置在角落，與紅框完全避開，且保持在線上)
            const targets = [
                {x: CX, y: CY},                       // 中心主電源 (唯一在中間的)
                {x: BOXES[0].x + BOXES[0].w, y: BOXES[0].y}, // 外層右上角
                {x: BOXES[0].x, y: BOXES[0].y + BOXES[0].h}, // 外層左下角
                {x: BOXES[1].x + BOXES[1].w, y: BOXES[1].y}, // 中層右上角
                {x: BOXES[2].x, y: BOXES[2].y},              // 內層左上角
                {x: BOXES[1].x, y: BOXES[1].y + BOXES[1].h}  // 中層左下角
            ];

            targets.forEach(t => {
                ctx.strokeStyle = "#00ffcc";
                ctx.beginPath(); 
                ctx.arc(t.x, t.y, 22, 0, Math.PI*2); 
                ctx.stroke();
                // 核心點
                ctx.fillStyle = "#00ffcc";
                ctx.beginPath(); ctx.arc(t.x, t.y, 4, 0, Math.PI*2); ctx.fill();
            });
        }

        drawMap();
    </script>
</body>
</html>

