<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>PCB DYNAMIC LOGIC TERMINAL</title>
    <style>
        :root { --green: #3cf08d; --bg: #050806; --wire: #1a251e; }
        body { background: var(--bg); color: var(--green); font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; margin: 0; }
        #ui { width: 360px; margin-top: 20px; display: flex; justify-content: space-between; padding: 10px; border-bottom: 2px solid var(--wire); }
        #board { position: relative; width: 360px; height: 400px; background: #000; border: 2px solid #333; margin-top: 15px; }
        canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
        .socket { position: absolute; width: 44px; height: 44px; background: #111; border: 2px dashed #444; z-index: 10; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .socket.filled { border: 2px solid #555; }
        .socket svg { width: 36px; height: 36px; stroke: #333; stroke-width: 5; fill: none; transition: 0.1s; }
        .socket.powered svg { stroke: var(--green); filter: drop-shadow(0 0 5px var(--green)); }
        .cell { position: absolute; width: 14px; height: 14px; border: 2px solid #333; border-radius: 50%; z-index: 50; background: #000; }
        .cell.lit { background: var(--green); border-color: #fff; box-shadow: 0 0 15px var(--green); }
        #inv { width: 360px; margin-top: 15px; display: flex; gap: 8px; background: #111; padding: 10px; box-sizing: border-box; }
        .item { width: 55px; height: 55px; border: 2px solid #444; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; }
        .item.active { border-color: var(--green); background: #0a150f; }
        .item svg { width: 25px; height: 25px; stroke: var(--green); stroke-width: 3; fill: none; }
    </style>
</head>
<body>

<div id="ui">
    <div id="stage-info">STAGE 1</div>
    <div id="stat">NODES: 0 / 3</div>
</div>

<div id="board">
    <canvas id="cvs" width="360" height="400"></canvas>
</div>

<div id="inv">
    <div class="item" onclick="selP('L')" id="iL"><svg viewBox="0 0 40 40"><path d="M20 5 V20 H35" /></svg></div>
    <div class="item" onclick="selP('T')" id="iT"><svg viewBox="0 0 40 40"><path d="M5 20 H35 M20 20 V35" /></svg></div>
    <div class="item" onclick="selP('X')" id="iX"><svg viewBox="0 0 40 40"><path d="M5 20 H35 M20 5 V35" /></svg></div>
    <div class="item" id="dl-item" style="display:none" onclick="selP('DL')"><svg viewBox="0 0 40 40"><path d="M20 5 A15 15 0 0 1 35 20 M5 20 A15 15 0 0 0 20 35" /></svg></div>
    <button onclick="reset()" style="margin-left:auto; background:#000; color:#888;">RESET</button>
</div>

<script>
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');
let sel = null, curLv = 1;
let sockets = [], cells = [], wires = [];

// 端口定義：0:上, 1:右, 2:下, 3:左
const COMP_LOGIC = {
    'L': (r) => { 
        const base = [[0,1], [1,2], [2,3], [3,0]]; 
        return base[r/90];
    },
    'T': (r) => {
        const base = [[1,2,3], [0,1,2], [0,1,3], [0,2,3]]; // 0:腳朝下通左下右, 90:腳朝左通上右下...
        return base[r/90];
    },
    'X': (r) => [0,1,2,3],
    'DL': (r) => {
        const base = [[[0,1],[2,3]], [[1,2],[3,0]]]; // 雙L：一組通上右，一組通下左
        return base[(r/90)%2];
    }
};

const levels = {
    1: { goal:3, inv:{L:3, T:1, X:0, DL:0}, 
        s:[{x:180,y:80},{x:80,y:180},{x:280,y:180}],
        c:[{x:30,y:180},{x:180,y:300},{x:330,y:180}],
        w:[
            {f:[180,0], t:[180,80], powerSource:true}, // 主電源入
            {f:[180,80], t:[80,80], sid:0, portF:3}, // 從s0的左邊出
            {f:[80,80], t:[80,180], sid:1, portT:0}, // 進入s1的上邊
            {f:[180,80], t:[280,80], sid:0, portF:1}, // 從s0的右邊出
            {f:[280,80], t:[280,180], sid:2, portT:0}, // 進入s2的上邊
            {f:[180,80], t:[180,300], sid:0, portF:2}, // 從s0的下邊出
            {f:[80,180], t:[30,180], sid:1, portF:3}, // 從s1的左邊出
            {f:[280,180], t:[330,180], sid:2, portF:1} // 從s2的右邊出
        ]
    }
    // 更多關卡可在此擴展
};

function selP(t){ sel=t; document.querySelectorAll('.item').forEach(i=>i.classList.toggle('active',i.id==='i'+(t==='CROSS'?'X':t))); }

function initStage(lv){
    curLv=lv; sockets=[]; cells=[]; wires=JSON.parse(JSON.stringify(levels[lv].w));
    document.getElementById('dl-item').style.display = (lv>=3?'flex':'none');
    document.getElementById('board').querySelectorAll('.socket,.cell').forEach(e=>e.remove());
    levels[lv].s.forEach((p,i)=>{
        const d=document.createElement('div'); d.className='socket'; d.style.left=(p.x-22)+'px'; d.style.top=(p.y-22)+'px';
        const sObj={id:i, x:p.x, y:p.y, type:null, rot:0, el:d};
        d.onclick=()=>{ if(!sObj.type && sel){ sObj.type=sel; sel=null; } else if(sObj.type){ sObj.rot=(sObj.rot+90)%360; } update(); };
        sockets.push(sObj); document.getElementById('board').appendChild(d);
    });
    levels[lv].c.forEach(p=>{
        const d=document.createElement('div'); d.className='cell'; d.style.left=(p.x-7)+'px'; d.style.top=(p.y-7)+'px';
        cells.push({x:p.x, y:p.y, el:d}); document.getElementById('board').appendChild(d);
    });
    update();
}

function update(){
    wires.forEach(w=>w.p=false);
    let changed = true;
    while(changed){
        changed = false;
        wires.forEach(w=>{
            if(w.p) return;
            // 判斷這條線是否能從起點獲得電力
            let hasPowerAtStart = w.powerSource || wires.some(sw=>sw.p && sw.t[0]===w.f[0] && sw.t[1]===w.f[1]);
            
            if(hasPowerAtStart){
                // 如果這條線是從某個組件發出的 (portF)
                if(w.sid !== undefined && w.portF !== undefined){
                    const s = sockets[w.sid];
                    if(s.type){
                        const ports = COMP_LOGIC[s.type](s.rot);
                        // 1. 檢查電力是否能進入該組件 (必須從反方向端口進入)
                        // 這裡簡化：假設sid組件本身已被電力觸及
                        let componentIsPowered = (s.id===0) || wires.some(sw=>sw.p && sw.sid===s.id && sw.portT !== undefined);
                        if(componentIsPowered){
                            // 2. 檢查該方向端口是否開啟
                            if(ports.flat().includes(w.portF)){ w.p=true; changed=true; }
                        }
                    }
                } else if(w.sid !== undefined && w.portT !== undefined){
                    // 如果這條線是進入某個組件的 (portT)
                    const s = sockets[w.sid];
                    if(s.type){
                        const ports = COMP_LOGIC[s.type](s.rot);
                        if(ports.flat().includes(w.portT)){ w.p=true; changed=true; }
                    }
                } else if(w.sid === undefined){
                    // 普通導線
                    w.p=true; changed=true;
                }
            }
        });
    }

    sockets.forEach(s=>{
        if(s.type){
            s.el.innerHTML=`<svg viewBox="0 0 40 40" style="transform:rotate(${s.rot}deg)">${getSVG(s.type)}</svg>`;
            s.el.classList.toggle('powered', wires.some(w=>w.p && w.sid===s.id));
        }
    });
    cells.forEach(c=>c.el.classList.toggle('lit', wires.some(w=>w.p && w.t[0]===c.x && w.t[1]===c.y)));
    draw();
}

function getSVG(t){
    if(t==='L') return '<path d="M20 5 V20 H35" />';
    if(t==='T') return '<path d="M5 20 H35 M20 20 V35" />';
    if(t==='X') return '<path d="M5 20 H35 M20 5 V35" />';
    if(t==='DL') return '<path d="M20 5 A15 15 0 0 1 35 20 M5 20 A15 15 0 0 0 20 35" />';
}

function draw(){
    ctx.clearRect(0,0,360,400);
    wires.forEach(w=>{
        ctx.beginPath(); ctx.moveTo(w.f[0],w.f[1]); ctx.lineTo(w.t[0],w.t[1]);
        ctx.strokeStyle=w.p?'#3cf08d':'#1a251e'; ctx.lineWidth=w.p?4:2;
        ctx.stroke();
    });
}
function reset(){ initStage(curLv); }
initStage(1);
</script>
</body>
</html>
