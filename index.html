<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RE2 CIRCUIT - MASTERMIND MODE</title>
    <style>
        @font-face {
            font-family: 'RE_Font';
            src: url('resident_evil_4_remake_font_by_snakeyboy_df7kacs.ttf');
        }

        :root { 
            --pwr-color: #f1c40f; 
            --bg-color: #050505;
            --re-red: #8b0000;
            --locked-bg: #2b0000;
        }

        body { 
            background-color: var(--bg-color); color: #ccc; 
            font-family: 'RE_Font', 'Courier New', sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            margin: 0; height: 100vh; justify-content: center;
            background-image: radial-gradient(circle, #1a1a1a 0%, #000 100%);
            overflow: hidden;
        }

        h2 { color: var(--re-red); text-transform: uppercase; letter-spacing: 8px; margin-bottom: 10px; font-size: 2.2em; text-shadow: 0 0 15px rgba(139, 0, 0, 0.5); }

        #info-panel { 
            margin-bottom: 20px; font-size: 1.2em; display: flex; gap: 50px; 
            background: rgba(15, 15, 15, 0.95); padding: 12px 40px; border: 1px solid #333;
            box-shadow: inset 0 0 15px #000;
        }

        .timer { color: #ff0000; font-weight: bold; }
        #game-container { position: relative; padding: 60px; background: #0a0a0a; border: 4px solid #222; box-shadow: 0 0 100px #000; }
        #game-board { display: grid; gap: 5px; background: #000; padding: 5px; border: 1px solid #1a1a1a; }

        .port { position: absolute; font-size: 12px; font-weight: bold; text-transform: uppercase; z-index: 5; letter-spacing: 2px; }
        .in-p { color: var(--pwr-color); left: 10px; top: 85px; text-shadow: 0 0 8px var(--pwr-color); }
        .out-p { right: 10px; bottom: 85px; color: #333; transition: 0.3s; }
        .out-p.active { color: var(--pwr-color); text-shadow: 0 0 20px var(--pwr-color); }

        .tile { width: 75px; height: 75px; background: #111; cursor: pointer; position: relative; transition: transform 0.2s, background 0.2s; }
        .tile:hover:not(.locked) { background: #1a1a1a; }
        .tile.locked { cursor: not-allowed; background: var(--locked-bg); border: 1px solid #500; }
        .tile.locked::before { content: 'FIXED'; position: absolute; font-size: 8px; color: #f00; top: 2px; left: 2px; z-index: 10; opacity: 0.7; }

        .wire { position: absolute; background: #2a2a2a; z-index: 1; transition: background 0.3s; }
        .tile::after { content: ''; position: absolute; width: 14px; height: 14px; background: #2a2a2a; left: 30.5px; top: 30.5px; border-radius: 2px; z-index: 2; }
        
        .w-up { width: 8px; height: 38px; left: 33.5px; top: 0; }
        .w-right { width: 38px; height: 8px; left: 37.5px; top: 33.5px; }
        .w-down { width: 8px; height: 38px; left: 33.5px; top: 37.5px; }
        .w-left { width: 38px; height: 8px; left: 0; top: 33.5px; }

        .powered .wire:not(.fake), .powered::after { background: var(--pwr-color) !important; box-shadow: 0 0 15px var(--pwr-color); }
        
        /* 假線閃爍 */
        .flicker .wire.fake { animation: failure 0.4s infinite alternate; }
        @keyframes failure {
            from { background: var(--pwr-color); box-shadow: 0 0 12px var(--pwr-color); }
            to { background: #2a2a2a; box-shadow: none; }
        }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.98); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        #status-text { font-size: 4em; margin-bottom: 20px; font-family: 'RE_Font', serif; letter-spacing: 5px; }
        
        .stranger-text { 
            color: #f1c40f; font-size: 2.5em !important; 
            line-height: 2.8; letter-spacing: 18px !important; 
            text-shadow: 0 0 40px rgba(241, 196, 15, 0.9); 
            white-space: pre-line;
        }

        button { background: transparent; color: #fff; border: 1px solid #444; padding: 15px 60px; cursor: pointer; font-size: 1.5em; font-family: 'RE_Font', sans-serif; letter-spacing: 3px; }
        button:hover { background: #600; border-color: #f00; }
    </style>
</head>
<body>

    <h2>CIRCUIT CONTROL: OVERLOAD</h2>
    
    <div id="info-panel">
        <div>LVL: <span id="lvl-display">1</span></div>
        <div class="timer">SEC: <span id="time-display">60</span></div>
    </div>

    <div id="game-container">
        <div class="port in-p">INPUT</div>
        <div id="game-board"></div>
        <div id="out-label" class="port out-p">OUTPUT</div>
    </div>

    <div id="overlay" class="overlay">
        <h1 id="status-text"></h1>
        <button id="action-btn" onclick="handleBtnClick()">RETRY</button>
    </div>

<script>
    const levels = [
        {size: 3, locks: 0, fakeChance: 0, deadTiles: 0},
        {size: 4, locks: 3, fakeChance: 0.5, deadTiles: 2},
        {size: 5, locks: 8, fakeChance: 0.85, deadTiles: 5} // 第 3 關強化
    ];
    let currentLvl = 0, timeLeft = 60, timerId = null, tiles = [], isLocked = false;

    function startGame() {
        isLocked = false;
        document.getElementById('overlay').style.display = 'none';
        const cfg = levels[currentLvl];
        document.getElementById('lvl-display').innerText = currentLvl + 1;
        document.getElementById('out-label').classList.remove('active');
        generateHardcoreLevel(cfg);
        startTimer();
    }

    function generateHardcoreLevel(cfg) {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        boardEl.style.gridTemplateColumns = `repeat(${cfg.size}, 75px)`;
        tiles = [];

        const grid = Array.from({length: cfg.size}, () => Array.from({length: cfg.size}, () => ({real:[], fake:[], isDead: false})));
        
        // 1. 產生極度曲折的路徑
        let r = 0, c = 0;
        grid[r][c].real.push(3);
        const path = [[0,0]];
        while(r < cfg.size - 1 || c < cfg.size - 1) {
            let possible = [];
            if(r < cfg.size - 1) possible.push([r+1, c, 2, 0]);
            if(c < cfg.size - 1) possible.push([r, c+1, 1, 3]);
            
            // 隨機選一個但給予方向權重，避免太直
            let choice = (Math.random() > 0.4) ? possible[possible.length-1] : possible[0];
            grid[r][c].real.push(choice[2]);
            r = choice[0]; c = choice[1];
            grid[r][c].real.push(choice[3]);
            path.push([r, c]);
        }
        grid[cfg.size-1][cfg.size-1].real.push(1);

        // 2. 隨機標記「死路格子」(完全不通電的裝飾格子)
        let deadCount = 0;
        while(deadCount < cfg.deadTiles) {
            let dr = Math.floor(Math.random()*cfg.size), dc = Math.floor(Math.random()*cfg.size);
            if(grid[dr][dc].real.length === 0) {
                grid[dr][dc].isDead = true;
                grid[dr][dc].fake = [0,1,2,3].sort(() => 0.5 - Math.random()).slice(0, 2);
                deadCount++;
            }
        }

        // 3. 固定塊佈置 (更嚴密的間隔)
        let lockIdx = new Set();
        let flatPath = path.map(p => p[0]*cfg.size + p[1]);
        flatPath.sort(() => 0.5 - Math.random());
        for(let idx of flatPath) {
            if(lockIdx.size >= cfg.locks) break;
            if(idx === 0 || idx === cfg.size*cfg.size-1) continue;
            let pr = Math.floor(idx/cfg.size), pc = idx%cfg.size;
            let clear = true;
            lockIdx.forEach(l => {
                if(Math.abs(Math.floor(l/cfg.size)-pr) + Math.abs((l%cfg.size)-pc) < 2) clear = false;
            });
            if(clear) lockIdx.add(idx);
        }

        for(let r=0; r<cfg.size; r++) {
            for(let c=0; c<cfg.size; c++) {
                let data = grid[r][c];
                const idx = r*cfg.size + c;

                // 填入混淆線路
                if(!data.isDead && data.real.length > 0 && Math.random() < cfg.fakeChance) {
                    let possible = [0,1,2,3].filter(d => !data.real.includes(d));
                    data.fake.push(possible[Math.floor(Math.random()*possible.length)]);
                } else if (!data.isDead && data.real.length === 0) {
                    // 非正確路徑的普通格子填充
                    data.fake = [[0,2],[1,3],[0,1,2]][Math.floor(Math.random()*3)];
                }

                const wrap = document.createElement('div');
                wrap.className = 'tile' + (lockIdx.has(idx) ? ' locked' : '');
                let rot = lockIdx.has(idx) ? 0 : Math.floor(Math.random()*4);

                const tileObj = {
                    element: wrap, real: data.real, fake: data.fake, rot: rot,
                    isLocked: lockIdx.has(idx),
                    getPowerExits: function() { return this.real.map(d => (d + this.rot) % 4); }
                };

                tileObj.real.forEach(d => {
                    let w = document.createElement('div');
                    w.className = 'wire ' + ['w-up','w-right','w-down','w-left'][d];
                    wrap.appendChild(w);
                });
                tileObj.fake.forEach(d => {
                    let w = document.createElement('div');
                    w.className = 'wire fake ' + ['w-up','w-right','w-down','w-left'][d];
                    wrap.appendChild(w);
                });

                wrap.style.transform = `rotate(${rot * 90}deg)`;
                wrap.onclick = () => {
                    if(isLocked || tileObj.isLocked) return;
                    tileObj.rot = (tileObj.rot + 1) % 4;
                    wrap.style.transform = `rotate(${tileObj.rot * 90}deg)`;
                    checkCircuit();
                };
                boardEl.appendChild(wrap);
                tiles.push(tileObj);
            }
        }
        checkCircuit();
    }

    function checkCircuit() {
        const size = levels[currentLvl].size;
        tiles.forEach(t => t.element.classList.remove('powered', 'flicker'));

        const powered = new Set(), queue = [];
        if(tiles[0].getPowerExits().includes(3)) queue.push(0);

        while(queue.length > 0) {
            const idx = queue.shift();
            if(powered.has(idx)) continue;
            powered.add(idx);
            tiles[idx].element.classList.add('powered');
            if(tiles[idx].fake.length > 0) tiles[idx].element.classList.add('flicker');

            const r = Math.floor(idx/size), c = idx%size;
            const exits = tiles[idx].getPowerExits();
            const nbs = [{d:0,nr:r-1,nc:c,o:2},{d:1,nr:r,nc:c+1,o:3},{d:2,nr:r+1,nc:c,o:0},{d:3,nr:r,nc:c-1,o:1}];
            
            nbs.forEach(n => {
                if(exits.includes(n.d) && n.nr>=0 && n.nr<size && n.nc>=0 && n.nc<size) {
                    const nidx = n.nr*size+n.nc;
                    if(tiles[nidx].getPowerExits().includes(n.o)) queue.push(nidx);
                }
            });
        }

        const win = powered.has(tiles.length-1) && tiles[tiles.length-1].getPowerExits().includes(1);
        document.getElementById('out-label').classList.toggle('active', win);
        if(win) {
            isLocked = true; clearInterval(timerId);
            setTimeout(() => {
                if(currentLvl < levels.length - 1) showOverlay("ALIVE", "NEXT LEVEL");
                else showOverlay("Congratulations, stranger!\nPlease claim your reward.", "");
            }, 800);
        }
    }

    function startTimer() {
        clearInterval(timerId);
        timerId = setInterval(() => {
            if(!isLocked) { timeLeft--; document.getElementById('time-display').innerText = timeLeft; if(timeLeft <= 0) endGame(); }
        }, 1000);
    }

    function endGame() { isLocked = true; clearInterval(timerId); showOverlay("YOU ARE DEAD", "RETRY"); }

    function showOverlay(msg, btnTxt) {
        const o = document.getElementById('overlay'), t = document.getElementById('status-text'), b = document.getElementById('action-btn');
        t.innerText = msg; b.innerText = btnTxt;
        if(msg.includes("Congratulations")) { t.className = "stranger-text"; b.classList.add("hidden"); }
        else { t.className = (msg === "ALIVE") ? "alive-text" : "dead-text"; b.classList.remove("hidden"); }
        o.style.display = 'flex';
    }

    function handleBtnClick() { 
        if(document.getElementById('action-btn').innerText === "NEXT LEVEL") currentLvl++; 
        else currentLvl = 0;
        timeLeft = 60;
        startGame(); 
    }

    startGame();
</script>
</body>
</html>
