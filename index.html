<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路維修 - 層級連動版</title>
    <style>
        body { background: #050505; color: #eee; text-align: center; font-family: 'Segoe UI', sans-serif; margin: 0; }
        h2 { margin: 10px 0 5px; color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        p { margin: 5px 0 15px; color: #888; font-size: 14px; }
        canvas { background: #000; border: 2px solid #333; cursor: pointer; display: block; margin: 0 auto; box-shadow: 0 0 30px #001100; }
    </style>
</head>
<body>

    <h2>系統狀態: <span id="status" style="color:#ff3333">斷線</span></h2>
    <p>點擊數字紅框，該層級 (1-4) 的所有符號將同步旋轉</p>
    <canvas id="gameCanvas" width="800" height="850"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        const CX = 400; 
        const CY = 480; 
        // 定義四層 (由外到內: Layer 0=最外層=4號, Layer 3=最內層=1號)
        // 注意：為了符合您的圖片(1在內, 4在外)，我們顯示時會轉換一下
        const BOX_SIZES = [600, 460, 320, 180]; 
        
        let nodes = [];
        let segments = [];
        let targets = [];

        // --- 1. 初始化與通關保證邏輯 ---
        function initGame() {
            nodes = [];
            segments = [];
            targets = [];
            
            // A. 先建立一個 "絕對能通關" 的完美狀態 (The Solved State)
            // 策略：所有十字軸上的點都用 T 型連接軸線，確保主幹道暢通
            // 這樣至少能保證電力能從中心向外擴散
            
            BOX_SIZES.forEach((size, i) => {
                const half = size / 2;
                // Layer Index: 0(外)..3(內)
                // Display Number: 4..1
                const layerNum = 4 - i; 

                // 為了保證通關，我們預設一組 "正確答案" (Winning Rotation)
                // 上(T): 連接 上/下/右 (Rot 1)
                // 右(T): 連接 左/右/下 (Rot 2)
                // 下(T): 連接 上/下/左 (Rot 3)
                // 左(T): 連接 上/下/右 (Rot 1)? 不，左邊要接上/下/左 -> Rot 3 (Left, Up, Down) 
                // 這裡我們設定一組強連通的 T 字配置
                
                // Top Node (需要在垂直線上導通)
                nodes.push({ id: `L${i}_T`, layer: i, x: CX, y: CY - half, type: 'T', rot: 1, winRot: 1, display: layerNum }); 
                // Right Node (需要在水平線上導通)
                nodes.push({ id: `L${i}_R`, layer: i, x: CX + half, y: CY, type: 'T', rot: 2, winRot: 2, display: layerNum });
                // Bottom Node
                nodes.push({ id: `L${i}_B`, layer: i, x: CX, y: CY + half, type: 'T', rot: 3, winRot: 3, display: layerNum });
                // Left Node
                nodes.push({ id: `L${i}_L`, layer: i, x: CX - half, y: CY, type: 'T', rot: 0, winRot: 0, display: layerNum });
            });

            // B. 打亂 (Scramble)
            // 為每一層生成一個隨機偏移量 (0~3)
            // 這樣整層一起轉，玩家只要轉回這個偏移量就能解開
            for(let layer=0; layer<4; layer++) {
                let scramble = Math.floor(Math.random() * 4); // 隨機轉 0~3 次
                nodes.forEach(n => {
                    if (n.layer === layer) {
                        n.rot = (n.winRot + scramble) % 4;
                    }
                });
            }

            // C. 建立虛擬節點與路徑 (不變的邏輯)
            // Battery Source
            const sourceNode = { id: 'SOURCE', x: CX, y: 50, type: 'SOURCE', rot: 2, powered: true }; 

            // 建立連線 Segments
            // 1. Source -> L0_T
            addSegment('SOURCE', 'L0_T', [[CX, 70], [CX, CY - 300]]);
            
            // 2. 垂直軸 & 水平軸
            for(let i=0; i<3; i++) {
                addSegment(`L${i}_T`, `L${i+1}_T`, [[CX, CY-BOX_SIZES[i]/2], [CX, CY-BOX_SIZES[i+1]/2]]); // Top Axis
                addSegment(`L${i}_B`, `L${i-1}_B`, [[CX, CY+BOX_SIZES[i]/2], [CX, CY+BOX_SIZES[i-1]/2]]); // Bottom Axis
                addSegment(`L${i}_L`, `L${i+1}_L`, [[CX-BOX_SIZES[i]/2, CY], [CX-BOX_SIZES[i+1]/2, CY]]); // Left Axis
                addSegment(`L${i}_R`, `L${i-1}_R`, [[CX+BOX_SIZES[i]/2, CY], [CX+BOX_SIZES[i-1]/2, CY]]); // Right Axis
            }
            // 中心連接 (穿過中心)
            addSegment('L3_T', 'L3_B', [[CX, CY-90], [CX, CY+90]]);
            addSegment('L3_L', 'L3_R', [[CX-90, CY], [CX+90, CY]]);

            // 3. 環狀連接 (角落)
            BOX_SIZES.forEach((size, i) => {
                const h = size/2;
                addSegment(`L${i}_T`, `L${i}_R`, [[CX, CY-h], [CX+h, CY-h], [CX+h, CY]]);
                addSegment(`L${i}_R`, `L${i}_B`, [[CX+h, CY], [CX+h, CY+h], [CX, CY+h]]);
                addSegment(`L${i}_B`, `L${i}_L`, [[CX, CY+h], [CX-h, CY+h], [CX-h, CY]]);
                addSegment(`L${i}_L`, `L${i}_T`, [[CX-h, CY], [CX-h, CY-h], [CX, CY-h]]);
            });

            // D. 配置目標 (Targets) - 確保在角落
            targets.push({ x: CX + 300, y: CY - 300, segIdx: findSegIndex('L0_T', 'L0_R') }); // 外圈右上
            targets.push({ x: CX - 300, y: CY + 300, segIdx: findSegIndex('L0_B', 'L0_L') }); // 外圈左下
            targets.push({ x: CX + 230, y: CY + 230, segIdx: findSegIndex('L1_R', 'L1_B') }); // 二圈右下
            targets.push({ x: CX - 160, y: CY - 160, segIdx: findSegIndex('L2_L', 'L2_T') }); // 三圈左上
            targets.push({ x: CX + 90, y: CY - 90, segIdx: findSegIndex('L3_T', 'L3_R') });   // 內圈右上
            targets.push({ x: CX, y: CY, segIdx: findSegIndex('L3_L', 'L3_R') });              // 中心
        }

        function addSegment(id1, id2, points) {
            segments.push({ from: id1, to: id2, points: points, powered: false });
        }
        function findSegIndex(id1, id2) {
            return segments.findIndex(s => (s.from===id1 && s.to===id2) || (s.from===id2 && s.to===id1));
        }

        // --- 2. 核心計算 (BFS) ---
        function calculatePower() {
            nodes.forEach(n => n.powered = false);
            segments.forEach(s => s.powered = false);
            targets.forEach(t => t.powered = false);

            let queue = ['SOURCE']; 
            let firstSeg = segments.find(s => s.from === 'SOURCE');
            if(firstSeg) { firstSeg.powered = true; queue.push(firstSeg.to); }

            while(queue.length > 0) {
                let currId = queue.shift();
                let currNode = nodes.find(n => n.id === currId);
                if (!currNode) continue;

                currNode.powered = true;

                // 判斷端口 (T型或L型)
                let ports = [];
                if (currNode.type === 'T') {
                    // T型: 0(上),1(右),2(下),3(左)。T型(rot=0)開口是Up,Left,Right -> 缺口是Down(2)
                    // 修正T型邏輯：通常 T shape 圖片是 "倒T" ┴。旋轉0時，橫槓在下，豎槓在上。連接左、右、上。缺口在下(2)。
                    let block = (currNode.rot + 2) % 4; 
                    for(let d=0; d<4; d++) if(d !== block) ports.push(d);
                } else {
                    // L型: rot=0 -> 連接 0(Up) & 1(Right)
                    ports.push(currNode.rot);
                    ports.push((currNode.rot + 1) % 4);
                }

                segments.forEach(seg => {
                    let neighborId = (seg.from === currId) ? seg.to : (seg.from === currId ? null : seg.from);
                    if (!neighborId) return;
                    if (seg.from !== currId && seg.to !== currId) return; // double check

                    // 計算方位
                    let neighborNode = nodes.find(n => n.id === neighborId);
                    let dx = 0, dy = 0;
                    if (neighborNode) { dx = neighborNode.x - currNode.x; dy = neighborNode.y - currNode.y; }
                    else if (neighborId === 'SOURCE') { dx = 0; dy = -1; }

                    let dir = -1;
                    if (Math.abs(dy) > Math.abs(dx)) dir = dy < 0 ? 0 : 2; // Up : Down
                    else dir = dx > 0 ? 1 : 3; // Right : Left

                    if (ports.includes(dir) && !seg.powered) {
                        seg.powered = true;
                        // 檢查鄰居是否接收
                        if (neighborNode) {
                            let neighborPorts = [];
                            if (neighborNode.type === 'T') {
                                let block = (neighborNode.rot + 2) % 4;
                                for(let d=0; d<4; d++) if(d !== block) neighborPorts.push(d);
                            } else {
                                neighborPorts.push(neighborNode.rot);
                                neighborPorts.push((neighborNode.rot + 1) % 4);
                            }
                            let incomeDir = (dir + 2) % 4;
                            if (neighborPorts.includes(incomeDir)) queue.push(neighborId);
                        }
                    }
                });
            }

            let litCount = targets.filter(t => segments[t.segIdx].powered).length;
            targets.forEach(t => t.powered = segments[t.segIdx].powered);
            
            if (litCount === targets.length) {
                statusEl.innerHTML = "系統修復完成！ (100%)";
                statusEl.style.color = "#00ff00";
            } else {
                statusEl.innerHTML = `電力供應中... (${litCount}/${targets.length})`;
                statusEl.style.color = "#ffcc00";
            }
        }

        // --- 3. 繪圖 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 電池
            ctx.fillStyle = "#1a1a1a"; ctx.fillRect(CX - 50, 20, 100, 50);
            ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.setLineDash([]); ctx.strokeRect(CX - 50, 20, 100, 50);
            ctx.fillStyle = "#00ffcc"; ctx.font = "bold 16px Arial"; ctx.fillText("POWER", CX - 30, 52);

            // 線路
            segments.forEach(seg => {
                ctx.beginPath();
                if (seg.powered) {
                    ctx.strokeStyle = "#00ffcc"; ctx.setLineDash([]); ctx.lineWidth = 3;
                    ctx.shadowBlur = 15; ctx.shadowColor = "#00ffcc";
                } else {
                    ctx.strokeStyle = "#333"; ctx.setLineDash([5, 8]); ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                }
                ctx.moveTo(seg.points[0][0], seg.points[0][1]);
                for(let i=1; i<seg.points.length; i++) ctx.lineTo(seg.points[i][0], seg.points[i][1]);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;

            // 目標
            targets.forEach(t => {
                ctx.beginPath();
                if (t.powered) {
                    ctx.fillStyle = "#00ff00"; ctx.strokeStyle = "#00ffcc"; ctx.shadowBlur = 20; ctx.shadowColor = "#00ff00";
                } else {
                    ctx.fillStyle = "#003311"; ctx.strokeStyle = "#006644"; ctx.shadowBlur = 0;
                }
                ctx.arc(t.x, t.y, 20, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = t.powered ? "#ffffff" : "#005533";
                ctx.beginPath(); ctx.arc(t.x, t.y, 6, 0, Math.PI*2); ctx.fill();
            });
            ctx.shadowBlur = 0;

            // 節點
            nodes.forEach(n => {
                // 紅框
                ctx.strokeStyle = "red"; ctx.lineWidth = 2; ctx.setLineDash([]);
                ctx.strokeRect(n.x - 25, n.y - 25, 50, 50);

                // 數字編號 (顯示 1~4)
                ctx.fillStyle = "#ff5555";
                ctx.font = "bold 12px Arial";
                // 畫在框框的角落或上方
                ctx.fillText(n.display, n.x + 15, n.y - 15);

                // 藍色符號
                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.rot * Math.PI / 2);
                ctx.strokeStyle = n.powered ? "#ffffff" : "#0055aa";
                ctx.lineWidth = 4; ctx.lineCap = "round";
                ctx.beginPath();
                if (n.type === 'T') {
                    ctx.moveTo(-15, 0); ctx.lineTo(15, 0); 
                    ctx.moveTo(0, 0); ctx.lineTo(0, -15);
                } else {
                    ctx.moveTo(0, -15); ctx.lineTo(0, 0); ctx.lineTo(15, 0);
                }
                ctx.stroke();
                ctx.restore();
            });
        }

        // --- 4. 點擊事件 (層級連動) ---
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // 檢查點擊
            let clickedLayer = -1;
            for (let n of nodes) {
                if (mx > n.x - 25 && mx < n.x + 25 && my > n.y - 25 && my < n.y + 25) {
                    clickedLayer = n.layer; // 抓出被點擊的是哪一層
                    break;
                }
            }

            if (clickedLayer !== -1) {
                // 連動邏輯：該層所有節點一起旋轉
                nodes.forEach(n => {
                    if (n.layer === clickedLayer) {
                        n.rot = (n.rot + 1) % 4;
                    }
                });
                calculatePower();
                draw();
            }
        });

        // 啟動
        initGame();
        calculatePower();
        draw();

    </script>
</body>
</html>
