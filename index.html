<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>電路解謎小遊戲</title>
    <style>
        body { background: #1a1a1a; color: white; text-align: center; font-family: sans-serif; }
        canvas { background: #ffffff; cursor: pointer; border: 5px solid #333; margin-top: 20px; }
        .controls { margin: 20px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>

    <h1>電路解謎遊戲</h1>
    <p>點擊紅色方框旋轉符號，連接電池（頂端黑色）與所有綠燈！</p>
    
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <div class="controls">
        <button onclick="checkWin()">檢查連線狀態</button>
        <p id="status"></p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 80;
        const padding = 60;

        // 定義符號類型
        // 0: T型, 1: L型, 2: 黃色雙變道(不交叉連通)
        const T_SHAPE = 0;
        const L_SHAPE = 1;
        const DOUBLE_CURVE = 2;

        // 模擬地圖數據 (部分範例)
        let nodes = [
            { x: 3, y: 0, type: T_SHAPE, rotation: 0, isPower: false }, // 電池下方第一個
            { x: 3, y: 1, type: L_SHAPE, rotation: 1, isPower: false },
            { x: 2, y: 1, type: DOUBLE_CURVE, rotation: 0, isPower: false },
            // 你可以在這裡依照圖片座標增加更多節點...
        ];

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 繪製頂部電池
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(250, 0, 100, 40);

            nodes.forEach(node => {
                const px = node.x * gridSize + padding;
                const py = node.y * gridSize + padding;

                // 繪製紅色框
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(px - 30, py - 30, 60, 60);

                // 根據旋轉角度繪製符號
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(node.rotation * Math.PI / 2);
                
                drawSymbol(node.type);
                ctx.restore();
            });
        }

        function drawSymbol(type) {
            ctx.lineWidth = 4;
            if (type === T_SHAPE) {
                ctx.strokeStyle = '#005596'; // 藍色
                ctx.beginPath();
                ctx.moveTo(-30, 0); ctx.lineTo(30, 0);
                ctx.moveTo(0, 0); ctx.lineTo(0, 30);
                ctx.stroke();
            } else if (type === L_SHAPE) {
                ctx.strokeStyle = '#005596';
                ctx.beginPath();
                ctx.moveTo(0, -30); ctx.lineTo(0, 0); ctx.lineTo(30, 0);
                ctx.stroke();
            } else if (type === DOUBLE_CURVE) {
                ctx.strokeStyle = '#ffee00'; // 黃色
                // 繪製兩條不相交的曲線 (雙彎道)
                ctx.beginPath();
                ctx.arc(-30, -30, 30, 0, Math.PI / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(30, 30, 30, Math.PI, Math.PI * 1.5);
                ctx.stroke();
            }
        }

        // 點擊旋轉邏輯
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            nodes.forEach(node => {
                const px = node.x * gridSize + padding;
                const py = node.y * gridSize + padding;
                if (mouseX > px - 30 && mouseX < px + 30 && mouseY > py - 30 && mouseY < py + 30) {
                    node.rotation = (node.rotation + 1) % 4;
                    draw();
                }
            });
        });

        function checkWin() {
            // 這裡需要實作 DFS 或 BFS 演算法來檢查從電池出發的連通性
            document.getElementById('status').innerText = "連線邏輯計算中... (需根據地圖完整座標實作)";
        }

        draw();
    </script>
</body>
</html>
